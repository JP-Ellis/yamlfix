{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"A simple opinionated yaml formatter that keeps your comments! Installing \u00b6 pip install yamlfix Usage \u00b6 Imagine we've got the following source code: book_library : - title : Why we sleep author : Matthew Walker - title : Harry Potter and the Methods of Rationality author : Eliezer Yudkowsky It has the following errors: There is no --- at the top. The indentation is all wrong. After running yamlfix the resulting source code will be: --- book_library : - title : Why we sleep author : Matthew Walker - title : Harry Potter and the Methods of Rationality author : Eliezer Yudkowsky yamlfix can be used both as command line tool and as a library. As a command line tool: $: yamlfix file.yaml As a library: from yamlfix import fix_files fix_files ([ 'file.py' ]) Features \u00b6 yamlfix will do the following changes in your code: Add the header --- to your file. Correct truthy strings : 'True' -> true, 'no' -> 'false' Remove unnecessary apostrophes: title: 'Why we sleep' -> title: Why we sleep . References \u00b6 As most open sourced programs, yamlfix is standing on the shoulders of giants, namely: yamlfmt Inspiration and alternative of this program. I created a new one because the pace of their pull requests is really slow, they don't have tests, CI pipelines or documentation. ruyaml A git based community maintained for of ruamel yaml parser. Click Used to create the command line interface. Contributing \u00b6 For guidance on setting up a development environment, and how to make a contribution to yamlfix , see Contributing to yamlfix .","title":"Overview"},{"location":"#installing","text":"pip install yamlfix","title":"Installing"},{"location":"#usage","text":"Imagine we've got the following source code: book_library : - title : Why we sleep author : Matthew Walker - title : Harry Potter and the Methods of Rationality author : Eliezer Yudkowsky It has the following errors: There is no --- at the top. The indentation is all wrong. After running yamlfix the resulting source code will be: --- book_library : - title : Why we sleep author : Matthew Walker - title : Harry Potter and the Methods of Rationality author : Eliezer Yudkowsky yamlfix can be used both as command line tool and as a library. As a command line tool: $: yamlfix file.yaml As a library: from yamlfix import fix_files fix_files ([ 'file.py' ])","title":"Usage"},{"location":"#features","text":"yamlfix will do the following changes in your code: Add the header --- to your file. Correct truthy strings : 'True' -> true, 'no' -> 'false' Remove unnecessary apostrophes: title: 'Why we sleep' -> title: Why we sleep .","title":"Features"},{"location":"#references","text":"As most open sourced programs, yamlfix is standing on the shoulders of giants, namely: yamlfmt Inspiration and alternative of this program. I created a new one because the pace of their pull requests is really slow, they don't have tests, CI pipelines or documentation. ruyaml A git based community maintained for of ruamel yaml parser. Click Used to create the command line interface.","title":"References"},{"location":"#contributing","text":"For guidance on setting up a development environment, and how to make a contribution to yamlfix , see Contributing to yamlfix .","title":"Contributing"},{"location":"contributing/","text":"We'd love you to contribute to yamlfix ! Issues \u00b6 Questions, feature requests and bug reports are all welcome as issues. To report a security vulnerability, please see our security policy instead. To make it as simple as possible for us to help you, please include the output of the following call in your issue: python -c \"import yamlfix.version; print(yamlfix.version.version_info())\" or if you have make installed, you can use make version . Please try to always include the above unless you're unable to install yamlfix or know it's not relevant to your question or feature request. Pull Requests \u00b6 yamlfix is released regularly so you should see your improvements release in a matter of days or weeks. Note Unless your change is trivial (typo, docs tweak etc.), please create an issue to discuss the change before creating a pull request. If you're looking for something to get your teeth into, check out the \"help wanted\" label on github. Development facilities \u00b6 To make contributing as easy and fast as possible, you'll want to run tests and linting locally. tl;dr : use make format to fix formatting, make to run tests and linting & make docs to build the docs. You'll need to have python 3.6, 3.7, or 3.8, virtualenv, git, and make installed. Clone your fork and go into the repository directory: git clone git@github.com:<your username>/yamlfix.git cd yamlfix Set up the virtualenv for running tests: virtualenv -p ` which python3.7 ` env source env/bin/activate Install yamlfix, dependencies and configure the pre-commits: make install Checkout a new branch and make your changes: git checkout -b my-new-feature-branch Fix formatting and imports: yamlfix uses black to enforce formatting and isort to fix imports. make format Run tests and linting: make There are more sub-commands in Makefile like test-code , test-examples , mypy or security which you might want to use, but generally make should be all you need. If you need to pass specific arguments to pytest use the ARGS variable, for example make test ARGS='-k test_markdownlint_passes' . Build documentation: If you have changed the documentation, make sure it builds the static site. Once built it will serve the documentation at localhost:8000 : make docs Commit, push, and create your pull request.","title":"Contributing"},{"location":"contributing/#issues","text":"Questions, feature requests and bug reports are all welcome as issues. To report a security vulnerability, please see our security policy instead. To make it as simple as possible for us to help you, please include the output of the following call in your issue: python -c \"import yamlfix.version; print(yamlfix.version.version_info())\" or if you have make installed, you can use make version . Please try to always include the above unless you're unable to install yamlfix or know it's not relevant to your question or feature request.","title":"Issues"},{"location":"contributing/#pull-requests","text":"yamlfix is released regularly so you should see your improvements release in a matter of days or weeks. Note Unless your change is trivial (typo, docs tweak etc.), please create an issue to discuss the change before creating a pull request. If you're looking for something to get your teeth into, check out the \"help wanted\" label on github.","title":"Pull Requests"},{"location":"contributing/#development-facilities","text":"To make contributing as easy and fast as possible, you'll want to run tests and linting locally. tl;dr : use make format to fix formatting, make to run tests and linting & make docs to build the docs. You'll need to have python 3.6, 3.7, or 3.8, virtualenv, git, and make installed. Clone your fork and go into the repository directory: git clone git@github.com:<your username>/yamlfix.git cd yamlfix Set up the virtualenv for running tests: virtualenv -p ` which python3.7 ` env source env/bin/activate Install yamlfix, dependencies and configure the pre-commits: make install Checkout a new branch and make your changes: git checkout -b my-new-feature-branch Fix formatting and imports: yamlfix uses black to enforce formatting and isort to fix imports. make format Run tests and linting: make There are more sub-commands in Makefile like test-code , test-examples , mypy or security which you might want to use, but generally make should be all you need. If you need to pass specific arguments to pytest use the ARGS variable, for example make test ARGS='-k test_markdownlint_passes' . Build documentation: If you have changed the documentation, make sure it builds the static site. Once built it will serve the documentation at localhost:8000 : make docs Commit, push, and create your pull request.","title":"Development facilities"},{"location":"editor_integration/","text":"For a smother experience, you can run yamlfix each time you save your file in your editor. Vim \u00b6 To integrate yamlfix into Vim, I recommend using the ale plugin . If you are new to ALE, check this post . ale is configured to run yamlfix automatically by default.","title":"Editor Integration"},{"location":"editor_integration/#vim","text":"To integrate yamlfix into Vim, I recommend using the ale plugin . If you are new to ALE, check this post . ale is configured to run yamlfix automatically by default.","title":"Vim"},{"location":"reference/","text":"yamlfix.__init__ special \u00b6 A simple opinionated yaml formatter that keeps your comments!. Functions fix_code: Fix yaml source code to correct missed or unused import statements. fix_files: Fix the yaml source code of a list of files. yamlfix.services \u00b6 Gather all the orchestration functionality required by the program to work. Classes and functions that connect the different domain model objects with the adapters and handlers to achieve the program's purpose. fix_code ( source_code ) \u00b6 Fix yaml source code to correct the format. It corrects these errors: * Add --- at the beginning of the file. * Correct truthy strings: 'True' -> true, 'no' -> 'false' * Remove unnecessary apostrophes: `title: 'Why we sleep'` -> `title: Why we sleep`. Parameters: Name Type Description Default source_code str Source code to be corrected. required Returns: Type Description str Corrected source code. Source code in yamlfix/services.py def fix_code ( source_code : str ) -> str : \"\"\"Fix yaml source code to correct the format. It corrects these errors: * Add --- at the beginning of the file. * Correct truthy strings: 'True' -> true, 'no' -> 'false' * Remove unnecessary apostrophes: `title: 'Why we sleep'` -> `title: Why we sleep`. Args: source_code: Source code to be corrected. Returns: Corrected source code. \"\"\" fixers = [ _fix_truthy_strings , _ruamel_yaml_fixer , _restore_truthy_strings , _fix_top_level_lists , ] for fixer in fixers : source_code = fixer ( source_code ) return source_code fix_files ( files ) \u00b6 Fix the yaml source code of a list of files. If the input is taken from stdin, it will output the value to stdout. Parameters: Name Type Description Default files Tuple[_io.TextIOWrapper] List of files to fix. required Returns: Type Description Optional[str] Fixed code retrieved from stdin or None. Source code in yamlfix/services.py def fix_files ( files : Tuple [ TextIOWrapper ]) -> Optional [ str ]: \"\"\"Fix the yaml source code of a list of files. If the input is taken from stdin, it will output the value to stdout. Args: files: List of files to fix. Returns: Fixed code retrieved from stdin or None. \"\"\" for file_wrapper in files : source = file_wrapper . read () fixed_source = fix_code ( source ) try : # Click testing runner doesn't simulate correctly the reading from stdin # instead of setting the name attribute to `<stdin>` it gives an # AttributeError. But when you use it outside testing, no AttributeError # is raised and name has the value <stdin>. So there is no way of testing # this behaviour. if file_wrapper . name == \"<stdin>\" : # pragma no cover output = \"output\" else : output = \"file\" except AttributeError : output = \"output\" if output == \"file\" : file_wrapper . seek ( 0 ) file_wrapper . write ( fixed_source ) file_wrapper . truncate () else : return fixed_source return None yamlfix.entrypoints special \u00b6 Define the different ways to expose the program functionality. Functions load_logger: Configure the Logging logger. load_logger ( verbose = False ) \u00b6 Configure the Logging logger. Parameters: Name Type Description Default verbose bool Set the logging level to Debug. False Source code in yamlfix/entrypoints/__init__.py def load_logger ( verbose : bool = False ) -> None : # pragma no cover \"\"\"Configure the Logging logger. Args: verbose: Set the logging level to Debug. \"\"\" logging . addLevelName ( logging . INFO , \"[ \\033 [36m+ \\033 [0m]\" ) logging . addLevelName ( logging . ERROR , \"[ \\033 [31m+ \\033 [0m]\" ) logging . addLevelName ( logging . DEBUG , \"[ \\033 [32m+ \\033 [0m]\" ) logging . addLevelName ( logging . WARNING , \"[ \\033 [33m+ \\033 [0m]\" ) if verbose : logging . basicConfig ( stream = sys . stderr , level = logging . DEBUG , format = \" %(levelname)s %(message)s \" ) else : logging . basicConfig ( stream = sys . stderr , level = logging . INFO , format = \" %(levelname)s %(message)s \" ) cli \u00b6 Command line interface definition. yamlfix.version \u00b6 Utilities to retrieve the information of the program version. version_info () \u00b6 Display the version of the program, python and the platform. Source code in yamlfix/version.py def version_info () -> str : \"\"\"Display the version of the program, python and the platform.\"\"\" info = { \"yamlfix version\" : __version__ , \"python version\" : sys . version . replace ( \" \\n \" , \" \" ), \"platform\" : platform . platform (), } return \" \\n \" . join ( f \" { k + ':' : >30 } { v } \" for k , v in info . items ())","title":"Reference"},{"location":"reference/#yamlfix.__init__","text":"A simple opinionated yaml formatter that keeps your comments!. Functions fix_code: Fix yaml source code to correct missed or unused import statements. fix_files: Fix the yaml source code of a list of files.","title":"__init__"},{"location":"reference/#yamlfix.services","text":"Gather all the orchestration functionality required by the program to work. Classes and functions that connect the different domain model objects with the adapters and handlers to achieve the program's purpose.","title":"services"},{"location":"reference/#yamlfix.services.fix_code","text":"Fix yaml source code to correct the format. It corrects these errors: * Add --- at the beginning of the file. * Correct truthy strings: 'True' -> true, 'no' -> 'false' * Remove unnecessary apostrophes: `title: 'Why we sleep'` -> `title: Why we sleep`. Parameters: Name Type Description Default source_code str Source code to be corrected. required Returns: Type Description str Corrected source code. Source code in yamlfix/services.py def fix_code ( source_code : str ) -> str : \"\"\"Fix yaml source code to correct the format. It corrects these errors: * Add --- at the beginning of the file. * Correct truthy strings: 'True' -> true, 'no' -> 'false' * Remove unnecessary apostrophes: `title: 'Why we sleep'` -> `title: Why we sleep`. Args: source_code: Source code to be corrected. Returns: Corrected source code. \"\"\" fixers = [ _fix_truthy_strings , _ruamel_yaml_fixer , _restore_truthy_strings , _fix_top_level_lists , ] for fixer in fixers : source_code = fixer ( source_code ) return source_code","title":"fix_code()"},{"location":"reference/#yamlfix.services.fix_files","text":"Fix the yaml source code of a list of files. If the input is taken from stdin, it will output the value to stdout. Parameters: Name Type Description Default files Tuple[_io.TextIOWrapper] List of files to fix. required Returns: Type Description Optional[str] Fixed code retrieved from stdin or None. Source code in yamlfix/services.py def fix_files ( files : Tuple [ TextIOWrapper ]) -> Optional [ str ]: \"\"\"Fix the yaml source code of a list of files. If the input is taken from stdin, it will output the value to stdout. Args: files: List of files to fix. Returns: Fixed code retrieved from stdin or None. \"\"\" for file_wrapper in files : source = file_wrapper . read () fixed_source = fix_code ( source ) try : # Click testing runner doesn't simulate correctly the reading from stdin # instead of setting the name attribute to `<stdin>` it gives an # AttributeError. But when you use it outside testing, no AttributeError # is raised and name has the value <stdin>. So there is no way of testing # this behaviour. if file_wrapper . name == \"<stdin>\" : # pragma no cover output = \"output\" else : output = \"file\" except AttributeError : output = \"output\" if output == \"file\" : file_wrapper . seek ( 0 ) file_wrapper . write ( fixed_source ) file_wrapper . truncate () else : return fixed_source return None","title":"fix_files()"},{"location":"reference/#yamlfix.entrypoints","text":"Define the different ways to expose the program functionality. Functions load_logger: Configure the Logging logger.","title":"entrypoints"},{"location":"reference/#yamlfix.entrypoints.load_logger","text":"Configure the Logging logger. Parameters: Name Type Description Default verbose bool Set the logging level to Debug. False Source code in yamlfix/entrypoints/__init__.py def load_logger ( verbose : bool = False ) -> None : # pragma no cover \"\"\"Configure the Logging logger. Args: verbose: Set the logging level to Debug. \"\"\" logging . addLevelName ( logging . INFO , \"[ \\033 [36m+ \\033 [0m]\" ) logging . addLevelName ( logging . ERROR , \"[ \\033 [31m+ \\033 [0m]\" ) logging . addLevelName ( logging . DEBUG , \"[ \\033 [32m+ \\033 [0m]\" ) logging . addLevelName ( logging . WARNING , \"[ \\033 [33m+ \\033 [0m]\" ) if verbose : logging . basicConfig ( stream = sys . stderr , level = logging . DEBUG , format = \" %(levelname)s %(message)s \" ) else : logging . basicConfig ( stream = sys . stderr , level = logging . INFO , format = \" %(levelname)s %(message)s \" )","title":"load_logger()"},{"location":"reference/#yamlfix.entrypoints.cli","text":"Command line interface definition.","title":"cli"},{"location":"reference/#yamlfix.version","text":"Utilities to retrieve the information of the program version.","title":"version"},{"location":"reference/#yamlfix.version.version_info","text":"Display the version of the program, python and the platform. Source code in yamlfix/version.py def version_info () -> str : \"\"\"Display the version of the program, python and the platform.\"\"\" info = { \"yamlfix version\" : __version__ , \"python version\" : sys . version . replace ( \" \\n \" , \" \" ), \"platform\" : platform . platform (), } return \" \\n \" . join ( f \" { k + ':' : >30 } { v } \" for k , v in info . items ())","title":"version_info()"}]}