{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"yamlfix","text":"<p>A simple opinionated yaml formatter that keeps your comments!</p>"},{"location":"#installing","title":"Installing","text":"<pre><code>pip install yamlfix\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<p>Imagine we've got the following source code:</p> <pre><code>book_library:\n- title: Why we sleep\nauthor: Matthew Walker\n- title: Harry Potter and the Methods of Rationality\nauthor: Eliezer Yudkowsky\n</code></pre> <p>It has the following errors:</p> <ul> <li>There is no <code>---</code> at the top.</li> <li>The indentation is all wrong.</li> </ul> <p>After running <code>yamlfix</code> the resulting source code will be:</p> <pre><code>book_library:\n- title: Why we sleep\nauthor: Matthew Walker\n- title: Harry Potter and the Methods of Rationality\nauthor: Eliezer Yudkowsky\n</code></pre> <p><code>yamlfix</code> can be used both as command line tool and as a library.</p> <p>To fix individual files: <pre><code>yamlfix file.yaml file2.yml\n</code></pre></p> <p>Apply recursively: <pre><code>yamlfix .\n</code></pre></p> <p>As a library:</p> <pre><code>from yamlfix import fix_files\n\nfix_files([\"file.py\"])\n</code></pre> <p>If instead of reading from a file you want to fix the code saved into a variable, use <code>fix_code</code>:</p> <pre><code>from yamlfix import fix_code\n\nsource_code = \"a: 1\"\n\nfixed_code = fix_code(source_code)\n\nassert fixed_code == \"---\\na: 1\\n\"\n</code></pre>"},{"location":"#features","title":"Features","text":"<p><code>yamlfix</code> will do the following changes in your yaml source code per default:</p> <ul> <li>Add the header <code>---</code> to your file.</li> <li>Correct truthy strings:   'True' -&gt; true, 'no' -&gt; 'false'</li> <li>Remove unnecessary apostrophes: <code>title: 'Why we sleep'</code> -&gt;   <code>title: Why we sleep</code>.</li> <li>Correct comments</li> <li>Ensure that there is exactly one newline at the end of each file, to comply   with the   POSIX standard.</li> <li>Split long lines.</li> <li>Respect Jinja2 syntax.</li> <li>Ensure a <code>\\n</code> exists at the end of the file.</li> <li>Convert short lists to flow-style <code>list: [item, item]</code></li> <li>Convert lists longer than line-width to block-style:   <pre><code>list:\n- item\n- item\n</code></pre></li> </ul>"},{"location":"#configuration","title":"Configuration","text":"<p><code>yamlfix</code> uses the <code>maison</code> library to find and parse configuration from standard locations, and can additionally be configured through environment variables.</p> <p>Any configuration found in the YamlfixConfig class can be set through your projects <code>pyproject.toml</code>, a custom <code>toml</code>-file or through the environment by providing an environment variable like <code>{yamlfix_env_prefix}_{yamlfix_config_key}</code>.</p> <p>Configuration options that are provided through environment variables have higher priority than options provided through configuration files and will override those keys.</p> <p>All provided configuration options, be it through <code>pyproject.toml</code>, config-files or env-vars, will be parsed by <code>pydantic</code>, so the target value type (str, bool, int, etc.) will be enforced, even if the provided value has the wrong type (for example all env vars in linux systems are strings, but pydantic will parse them to bools/numbers where necessary).</p>"},{"location":"#auto-configure-through-pyprojecttoml","title":"Auto-Configure through <code>pyproject.toml</code>","text":"<p>The <code>maison</code> library will automatically pick up your <code>yamlfix</code> configuration through your projects <code>pyproject.toml</code>. It will look in the section named <code>tool.yamlfix</code> and apply the provided configuration options. For example:</p> <pre><code># pyproject.toml\n\n[tool.yamlfix]\nallow_duplicate_keys = true\nline_length = 80\nnone_representation = \"null\"\n</code></pre>"},{"location":"#provide-config-files","title":"Provide config-files","text":"<p>When running <code>yamlfix</code> as a standalone cli application it might be desireable to provide a config file containing just the configuration related to <code>yamlfix</code>. A cli-argument <code>-c</code> (<code>--config-file</code>) can be provided multiple times to read configuration values from <code>toml</code> formatted files. The rightmost value-files override the value-files preceding them, only trumped by environment variables. No section headers are necessary for these configuration files, as the expected behaviour is, that those files contain only configuration related to <code>yamlfix</code>. For example:</p> <pre><code># run yamlfix with two config files\nyamlfix -c base.toml --config-file environment.toml file.yaml\n</code></pre> <pre><code># base.toml\nallow_duplicate_keys = false\nline_length = 100\n</code></pre> <pre><code># environment.toml\nallow_duplicate_keys = true\n</code></pre> <p>These provided configuration files would result in a merged runtime-configuration of: <pre><code># merged configuration\nallow_duplicate_keys = true\nline_length = 100\n</code></pre></p>"},{"location":"#configure-environment-prefix","title":"Configure environment prefix","text":"<p>Per default <code>yamlfix</code>, when run through cli, will read any environment variable that starts with <code>YAMLFIX_</code> and apply it to the merged runtime-configuration object. This default value can be overridden with the cli-parameter <code>--env-prefix</code>. For example:</p> <pre><code># set a configuration value with the default prefix\nexport YAMLFIX_LINE_LENGTH=\"300\"\n\n# set a configuration value with the custom prefix\nexport MY_PREFIX_NONE_REPRESENTATION=\"~\"\n\n# run yamlfix with a custom environment prefix\nyamlfix --env-prefix \"MY_PREFIX\" file.yaml\n</code></pre> <p>These provided arguments and environment variables would result in a merged runtime-configuration of: <pre><code># merged configuration\n# default value for line_length stays at: 80\nnone_representation = \"~\"\n</code></pre></p>"},{"location":"#configuration-options","title":"Configuration Options","text":"<p>All fields configured in the YamlfixConfig class can be provided through the means mentioned in Configuration. Here are the currently available configuration options with short examples on their impact to provided <code>yaml</code>-files.</p>"},{"location":"#allow-duplicate-keys","title":"Allow Duplicate Keys","text":"<p>Default: <code>allow_duplicate_keys: bool = False</code> Environment variable override: <pre><code>export YAMLFIX_ALLOW_DUPLICATE_KEYS=\"true\"\n</code></pre></p> <p>This option toggles the ruyaml duplicate keys check. With this setting set to <code>False</code>, <code>yamlfix</code> will throw an error if the same key is defined more than once in a mapping / dictionary. To allow using the same key, set this value to <code>True</code>. You might want to enable this option, if you want to use multiple yaml-anchor merge keys, instead of providing them as sequence / list elements - see: https://github.com/pycontribs/ruyaml/issues/43</p>"},{"location":"#comments-min-spaces-from-content","title":"Comments Min Spaces From Content","text":"<p>Default: <code>comments_min_spaces_from_content: int = 2</code> Environment variable override: <pre><code>export YAMLFIX_COMMENTS_MIN_SPACES_FROM_CONTENT=\"2\"\n</code></pre></p> <p>This option enforces minimum spacing between the content of a line and the start of an inline-comment. It is the enforcement implementation to the yamllint rule <code>rules.comments.min-spaces-from-content</code> - see: https://yamllint.readthedocs.io/en/stable/rules.html#module-yamllint.rules.comments</p>"},{"location":"#comments-require-starting-space","title":"Comments Require Starting Space","text":"<p>Default: <code>comments_require_starting_space: bool = True</code> Environment variable override: <pre><code>export YAMLFIX_COMMENTS_REQUIRE_STARTING_SPACE=\"true\"\n</code></pre></p> <p>This option enforces a space between the comment indicator (<code>#</code>) and the first character in the comment. It implements the enforcement of the yamllint rule <code>rules.comments.require-starting-space</code> - see: https://yamllint.readthedocs.io/en/stable/rules.html#module-yamllint.rules.comments</p>"},{"location":"#comments-whitelines","title":"Comments Whitelines","text":"<p>Default: <code>comments_whitelines: int = 1</code> Environment variable override: <pre><code>export YAMLFIX_COMMENTS_WHITELINES=\"1\"\n</code></pre></p> <p>This option allows to add a specific number of consecutive whitelines before a comment-only line.</p> <p>A comment-only line is defined as a line that starts with a comment or with an indented comment.</p> <p>Before a comment-only line, either:</p> <ul> <li>0 whiteline is allowed</li> <li>Exactly <code>comments_whitelines</code> whitelines are allowed</li> </ul>"},{"location":"#section-whitelines","title":"Section Whitelines","text":"<p>Default <code>section_whitelines: int = 0</code> Environment variable override: <pre><code>export YAMLFIX_SECTION_WHITELINES=\"1\"\n</code></pre></p> <p>This option sets the number of whitelines before and after a section. A section is defined as a top-level key followed by at least one line with indentation. Section examples: <pre><code>section1:\nkey: value\n\nlist:\n- value\n</code></pre> There are a few exceptions to this behaviour:</p> <ul> <li>If there is a comment(s) on the line(s) preceding beginning of a section, <code>comments_whitelines</code> rules will be applied to whitelines before the section. e.g. <pre><code># Comment\nsection:\nkey: value\n</code></pre></li> <li>Sections at the start and end of the document will have whitelines removed before and after respectively.</li> </ul>"},{"location":"#config-path","title":"Config Path","text":"<p>Default: <code>config_path: Optional[str] = None</code> Environment variable override: <pre><code>export YAMLFIX_CONFIG_PATH=\"/etc/yamlfix/\"\n</code></pre></p> <p>Configure the base config-path that <code>maison</code> will look for a <code>pyproject.toml</code> configuration file. This path is traversed upwards until such a file is found.</p>"},{"location":"#explicit-document-start","title":"Explicit Document Start","text":"<p>Default: <code>explicit_start: bool = True</code> Environment variable override: <pre><code>export YAMLFIX_EXPLICIT_START=\"true\"\n</code></pre></p> <p>Add or remove the explicit document start (<code>---</code>) for <code>yaml</code>-files. For example:</p> <p>Set to <code>true</code>: <pre><code>---\nproject_name: yamlfix\n</code></pre></p> <p>Set to <code>false</code>: <pre><code>project_name: yamlfix\n</code></pre></p>"},{"location":"#sequence-list-style","title":"Sequence (List) Style","text":"<p>Default: <code>sequence_style: YamlNodeStyle = YamlNodeStyle.FLOW_STYLE</code> Environment variable override: <pre><code>export YAMLFIX_SEQUENCE_STYLE=\"flow_style\"\n</code></pre></p> <p>Available values: <code>flow_style</code>, <code>block_style</code>, <code>keep_style</code></p> <p>Transform sequences (lists) to either flow-style, block-style or leave them as-is. If enabled <code>yamlfix</code> will also ensure, that flow-style lists are automatically converted to block-style if the resulting key+list elements would breach the line-length. For example:</p> <p>Set to <code>true</code> (flow-style): <pre><code>---\nlist: [item, item, item]\n</code></pre></p> <p>Set to <code>false</code> (block-style): <pre><code>---\nlist:\n- item\n- item\n- item\n</code></pre></p>"},{"location":"#indentation","title":"Indentation","text":"<p>Default: <code>indent_mapping: int = 2</code> <code>indent_offset: int = 2</code> <code>indent_sequence: int = 4</code> Environment variable override: <pre><code>export YAMLFIX_INDENT_MAPPING=\"2\"\nexport YAMLFIX_INDENT_OFFSET=\"2\"\nexport YAMLFIX_INDENT_SEQUENCE=\"4\"\n</code></pre></p> <p>Provide the <code>ruyaml</code> configuration for indentation of mappings (dicts) and sequences (lists) and the indentation offset for elements. See the <code>ruyaml</code> configuration documentation: https://ruyaml.readthedocs.io/en/latest/detail.html#indentation-of-block-sequences</p>"},{"location":"#line-length-width","title":"Line Length (Width)","text":"<p>Default: <code>line_length: int = 80</code> Environment variable override: <pre><code>export YAMLFIX_LINE_LENGTH=\"80\"\n</code></pre></p> <p>Configure the line-length / width configuration for <code>ruyaml</code>. With this configuration long multiline-strings will be wrapped at that point and flow-style lists will be converted to block-style if they are longer than the provided value.</p>"},{"location":"#none-representation","title":"<code>None</code> Representation","text":"<p>Default: <code>none_representation: str = \"\"</code> Environment variable override: <pre><code>export YAMLFIX_LINE_LENGTH=\"\"\n</code></pre></p> <p>In <code>yaml</code>-files an absence of a value can be described in multiple canonical ways. This configuration enforces a user-defined representation for <code>None</code> values. For example:</p> <p>Valid <code>None</code> representation values are <code>(empty string)</code>, <code>null</code>, <code>Null</code>, <code>NULL</code>, <code>~</code>.</p> <p>Provided the source yaml file looks like this: <pre><code>none_value1:\nnone_value2: null\nnone_value3: Null\nnone_value4: NULL\nnone_value5: ~\n</code></pre></p> <p>The default behaviour (empty string) representation would look like this: <pre><code>none_value1:\nnone_value2:\nnone_value3:\nnone_value4:\nnone_value5:\n</code></pre></p> <p>With this option set to <code>none_representation=\"null\"</code> it would look like this: <pre><code>none_value1: null\nnone_value2: null\nnone_value3: null\nnone_value4: null\nnone_value5: null\n</code></pre></p>"},{"location":"#quote-basic-values","title":"Quote Basic Values","text":"<p>Default: <code>quote_basic_values: bool = False</code> Environment variable override: <pre><code>export YAMLFIX_quote_basic_values=\"false\"\n</code></pre></p> <p>Per default <code>ruyaml</code> will quote only values where it is necessary to explicitly define the type of a value. This is the case for numbers and boolean values for example. If your <code>yaml</code>-file contains a value of type string that would look like a number, then this value needs to be quoted.</p> <p>This option allows for quoting of all simple values in mappings (dicts) and sequences (lists) to enable a homogeneous look and feel for string lists / simple key/value mappings. For example:</p> <pre><code># option set to false\nstringKey1: abc\nstringKey2: \"123\"\nstringList: [abc, \"123\"]\n</code></pre> <pre><code># option set to true\nstringKey1: \"abc\"\nstringKey2: \"123\"\nstringList: [\"abc\", \"123\"]\n</code></pre>"},{"location":"#quote-keys-and-basic-values","title":"Quote Keys and Basic Values","text":"<p>Default: <code>quote_keys_and_basic_values: bool = False</code> Environment variable override: <pre><code>export YAMLFIX_quote_keys_and_basic_values=\"false\"\n</code></pre></p> <p>Similar to the quote basic values configuration option, this option, in addition to the values themselves, quotes the keys as well. For example:</p> <pre><code># option set to false\nkey: value\nlist: [item, item]\n</code></pre> <pre><code># option set to true\n\"key\": \"value\"\n\"list\": [\"item\", \"item\"]\n</code></pre>"},{"location":"#quote-representation","title":"Quote Representation","text":"<p>Default: <code>quote_representation: str = \"'\"</code> Environment variable override: <pre><code>export YAMLFIX_quote_representation=\"'\"\n</code></pre></p> <p>Configure which quotation string is used for quoting values. For example:</p> <pre><code># Option set to: '\nkey: 'value'\n</code></pre> <pre><code># Option set to: \"\nkey: \"value\"\n</code></pre>"},{"location":"#references","title":"References","text":"<p>As most open sourced programs, <code>yamlfix</code> is standing on the shoulders of giants, namely:</p> <p>yamlfmt : Inspiration and alternative of this program. I created a new one because the pace of their pull requests is really slow, they don't have tests, CI pipelines or documentation.</p> <p>ruyaml : A git based community maintained for of ruamel yaml parser.</p> <p>Click : Used to create the command line interface.</p> <p>maison : Used for finding, reading and parsing the configuration options.</p> <p>Pytest : Testing framework, enhanced by the awesome pytest-cases library that made the parametrization of the tests a lovely experience.</p> <p>Mypy : Python static type checker.</p> <p>Flakeheaven : Python linter with lots of checks.</p> <p>Black : Python formatter to keep a nice style without effort.</p> <p>Autoimport : Python formatter to automatically fix wrong import statements.</p> <p>isort : Python formatter to order the import statements.</p> <p>PDM : Command line tool to manage the dependencies.</p> <p>Mkdocs : To build this documentation site, with the Material theme.</p> <p>Safety : To check the installed dependencies for known security vulnerabilities.</p> <p>Bandit : To finds common security issues in Python code.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>For guidance on setting up a development environment, and how to make a contribution to <code>yamlfix</code>, see Contributing to yamlfix.</p>"},{"location":"#donations","title":"Donations","text":"<p> or </p> <p>If you are using some of my open-source tools, have enjoyed them, and want to say \"thanks\", this is a very strong way to do it.</p> <p>If your product/company depends on these tools, you can sponsor me to ensure I keep happily maintaining them.</p> <p>If these tools are helping you save money, time, effort, or frustrations; or they are helping you make money, be more productive, efficient, secure, enjoy a bit more your work, or get your product ready faster, this is a great way to show your appreciation. Thanks for that!</p> <p>And by sponsoring me, you are helping make these tools, that already help you, sustainable and healthy.</p>"},{"location":"contributing/","title":"Contributing","text":"<p>So you've started using <code>yamlfix</code> and want to show your gratitude to the project, depending on your programming skills there are different ways to do so.</p>"},{"location":"contributing/#i-dont-know-how-to-program","title":"I don't know how to program","text":"<p>There are several ways you can contribute:</p> <ul> <li>Open an issue if you   encounter any bug or to let us know if you want a new feature to be   implemented.</li> <li>Spread the word about the program.</li> <li>Review the documentation and try to   improve it.</li> </ul>"},{"location":"contributing/#i-know-how-to-program-in-python","title":"I know how to program in Python","text":"<p>If you have some python knowledge there are some additional ways to contribute. We've ordered the issues in milestones, check the issues in the smaller one, as it's where we'll be spending most of our efforts. Try the good first issues, as they are expected to be easier to get into the project.</p> <p>We develop the program with TDD, so we expect any contribution to have it's associated tests. We also try to maintain an updated documentation of the project, so think if your contribution needs to update it.</p> <p>We know that the expected code quality is above average. Therefore it might be changeling to get the initial grasp of the project structure, know how to make the tests, update the documentation or use all the project technology stack. but please don't let this fact discourage you from contributing:</p> <ul> <li>If you want to develop a new feature, explain how you'd like to do it in the   related issue.</li> <li>If you don't know how to test your code, do the pull request without the tests   and we'll try to do them for you.</li> </ul>"},{"location":"contributing/#issues","title":"Issues","text":"<p>Questions, feature requests and bug reports are all welcome as issues. To report a security vulnerability, please see our security policy instead.</p> <p>To make it as simple as possible for us to help you, please include the output of the following call in your issue:</p> <pre><code>python -c \"import yamlfix.version; print(yamlfix.version.version_info())\"\n</code></pre> <p>or if you have <code>make</code> installed, you can use <code>make version</code>.</p> <p>Please try to always include the above unless you're unable to install <code>yamlfix</code> or know it's not relevant to your question or feature request.</p>"},{"location":"contributing/#pull-requests","title":"Pull Requests","text":"<p>yamlfix is released regularly so you should see your improvements release in a matter of days or weeks.</p> <p>Note</p> <p>Unless your change is trivial (typo, docs tweak etc.), please create an issue to discuss the change before creating a pull request.</p> <p>If you're looking for something to get your teeth into, check out the \"help wanted\" label on github.</p>"},{"location":"contributing/#development-facilities","title":"Development facilities","text":"<p>To make contributing as easy and fast as possible, you'll want to run tests and linting locally.</p> <p>tl;dr: use <code>make format</code> to fix formatting, <code>make</code> to run tests and linting &amp; <code>make docs</code> to build the docs.</p> <p>You'll need to have python 3.7 or 3.8, virtualenv, git, and make installed.</p> <ul> <li>Clone your fork and go into the repository directory:</li> </ul> <pre><code>git clone git@github.com:&lt;your username&gt;/yamlfix.git\ncd yamlfix\n</code></pre> <ul> <li>Set up the virtualenv for running tests:</li> </ul> <pre><code>virtualenv -p `which python3.7` env\nsource env/bin/activate\n</code></pre> <ul> <li>Install <code>pdm</code> our package manager with the next command or using any of the   other   recommended methods.</li> </ul> <pre><code>curl -sSL https://raw.githubusercontent.com/pdm-project/pdm/main/install-pdm.py | python3 -\n</code></pre> <ul> <li>Install yamlfix, dependencies and configure the pre-commits:</li> </ul> <pre><code>make install\n</code></pre> <ul> <li>Checkout a new branch and make your changes:</li> </ul> <pre><code>git checkout -b my-new-feature-branch\n</code></pre> <ul> <li>Fix formatting and imports: yamlfix uses   black to enforce formatting and   isort to fix imports.</li> </ul> <pre><code>make format\n</code></pre> <ul> <li>Run tests and linting:</li> </ul> <pre><code>make\n</code></pre> <p>There are more sub-commands in Makefile like <code>test-code</code>, <code>test-examples</code>,   <code>mypy</code> or <code>security</code> which you might want to use, but generally <code>make</code> should   be all you need.</p> <p>If you need to pass specific arguments to pytest use the <code>ARGS</code> variable, for   example <code>make test ARGS='-k test_markdownlint_passes'</code>.</p> <ul> <li>Build documentation: If you have changed the documentation, make sure it   builds the static site. Once built it will serve the documentation at   <code>localhost:8000</code>:</li> </ul> <pre><code>make docs\n</code></pre> <ul> <li> <p>Commit, push, and create your pull request.</p> </li> <li> <p>Make a new release: To generate the changelog of the new changes, build the   package, upload to pypi and clean the build files use <code>make bump</code>.</p> </li> </ul> <p>We'd love you to contribute to yamlfix!</p>"},{"location":"editor_integration/","title":"Editor Integration","text":"<p>For a smoother experience, you can run <code>yamlfix</code> automatically each time each time you save your file in your editor or when you run <code>git commit</code>.</p>"},{"location":"editor_integration/#vim","title":"Vim","text":"<p>To integrate <code>yamlfix</code> into Vim, I recommend using the ale plugin.</p> <p>If you are new to ALE, check this post.</p> <p><code>ale</code> is configured to run <code>yamlfix</code> automatically by default.</p>"},{"location":"editor_integration/#pre-commit","title":"pre-commit","text":"<p>You can run <code>yamlfix</code> before we do a commit using the pre-commit framework. If you don't know how to use it, follow these guidelines.</p> <p>You'll need to add the following lines to your project's <code>.pre-commit-config.yaml</code> file.</p> <pre><code>repos:\n- repo: https://github.com/lyz-code/yamlfix/\nrev: master\nhooks:\n- id: yamlfix\n</code></pre>"},{"location":"reference/","title":"Reference","text":""},{"location":"reference/#yamlfix.adapters","title":"<code>yamlfix.adapters</code>","text":"<p>Define adapter / helper classes to hide unrelated functionality in.</p>"},{"location":"reference/#yamlfix.adapters.SourceCodeFixer","title":"<code>SourceCodeFixer</code>","text":"<p>Adapter that holds all source code yaml fixers.</p> Source code in <code>yamlfix/adapters.py</code> <pre><code>class SourceCodeFixer:\n\"\"\"Adapter that holds all source code yaml fixers.\"\"\"\n\n    def __init__(self, yaml: Yaml, config: Optional[YamlfixConfig]) -&gt; None:\n\"\"\"Initialize the source code fixer adapter with a configured yaml fixer \\\n            instance and optional yamlfix config.\n\n        Args:\n            yaml: Initialized Ruamel formatter to use for source code correction.\n            config: Small set of user provided configuration options for yamlfix.\n        \"\"\"\n        self.yaml = yaml.yaml\n        self.config = config or YamlfixConfig()\n\n    def fix(self, source_code: str) -&gt; str:\n\"\"\"Run all yaml source code fixers.\n\n        Args:\n            source_code: Source code to be corrected.\n\n        Returns:\n            Corrected source code.\n        \"\"\"\n        log.debug(\"Running source code fixers...\")\n\n        fixers = [\n            self._fix_truthy_strings,\n            self._fix_jinja_variables,\n            self._ruamel_yaml_fixer,\n            self._restore_truthy_strings,\n            self._restore_jinja_variables,\n            self._restore_double_exclamations,\n            self._fix_comments,\n            self._fix_whitelines,\n            self._fix_top_level_lists,\n            self._fix_flow_style_lists,\n            self._add_newline_at_end_of_file,\n        ]\n\n        for fixer in fixers:\n            source_code = fixer(source_code)\n\n        return source_code\n\n    def _ruamel_yaml_fixer(self, source_code: str) -&gt; str:\n\"\"\"Run Ruamel's yaml fixer.\n\n        Args:\n            source_code: Source code to be corrected.\n\n        Returns:\n            Corrected source code.\n        \"\"\"\n        log.debug(\"Running ruamel yaml fixer...\")\n        source_dicts = self.yaml.load_all(source_code)\n\n        # Return the output to a string\n        string_stream = StringIO()\n        for source_dict in source_dicts:\n            self.yaml.dump(source_dict, string_stream)\n            source_code = string_stream.getvalue()\n        string_stream.close()\n\n        return source_code.strip()\n\n    @staticmethod\n    def _fix_top_level_lists(source_code: str) -&gt; str:\n\"\"\"Deindent the source with a top level list.\n\n        Documents like the following:\n\n        ```yaml\n        ---\n        # Comment\n        - item 1\n        - item 2\n        ```\n\n        Are wrongly indented by the ruyaml parser:\n\n        ```yaml\n        ---\n        # Comment\n        - item 1\n        - item 2\n        ```\n\n        This function restores the indentation back to the original.\n\n        Args:\n            source_code: Source code to be corrected.\n\n        Returns:\n            Corrected source code.\n        \"\"\"\n        log.debug(\"Fixing top level lists...\")\n        source_lines = source_code.splitlines()\n        fixed_source_lines: List[str] = []\n        is_top_level_list: Optional[bool] = None\n\n        indent: str = \"\"\n        for line in source_lines:\n            # Skip the heading and first empty lines\n            if re.match(r\"^(---|#.*|)$\", line):\n                fixed_source_lines.append(line)\n                continue\n\n            # Check if the first valid line is an indented list item\n            if re.match(r\"\\s*- +.*\", line) and is_top_level_list is None:\n                is_top_level_list = True\n\n                # Extract the indentation level\n                serialized_line = re.match(r\"(?P&lt;indent&gt;\\s*)- +(?P&lt;content&gt;.*)\", line)\n                if serialized_line is None:  # pragma: no cover\n                    raise ValueError(\n                        f\"Error extracting the indentation of line: {line}\"\n                    )\n                indent = serialized_line.groupdict()[\"indent\"]\n\n                # Remove the indentation from the line\n                fixed_source_lines.append(re.sub(rf\"^{indent}(.*)\", r\"\\1\", line))\n            elif is_top_level_list:\n                # ruyaml doesn't change the indentation of comments\n                if re.match(r\"\\s*#.*\", line):\n                    fixed_source_lines.append(line)\n                else:\n                    fixed_source_lines.append(re.sub(rf\"^{indent}(.*)\", r\"\\1\", line))\n            else:\n                return source_code\n\n        return \"\\n\".join(fixed_source_lines)\n\n    @staticmethod\n    def _fix_flow_style_lists(source_code: str) -&gt; str:\n\"\"\"Fix trailing newlines within flow-style lists.\n\n        Documents like the following:\n\n        ```yaml\n        ---\n        list: [\"a\", b, 'c']\n\n\n        next-element: \"d\"\n        ```\n\n        Are wrongly formatted by the ruyaml parser:\n\n        ```yaml\n        ---\n        list: [\"a\", b, 'c'\n\n\n        ]\n        next-element: \"d\"\n        ```\n\n        This function moves the closing bracket to the end of the flow-style\n        list definition.\n\n        Args:\n            source_code: Source code to be corrected.\n\n        Returns:\n            Corrected source code.\n        \"\"\"\n        log.debug(\"Fixing flow-style lists...\")\n        source_lines = source_code.splitlines()\n        reversed_fixed_source_lines: List[str] = []\n\n        should_append_square_brackets: bool = False\n        for line in reversed(source_lines):\n            if line == \"]\":\n                should_append_square_brackets = True\n                continue\n\n            if line == \"\":\n                reversed_fixed_source_lines.append(line)\n                continue\n\n            if should_append_square_brackets:\n                should_append_square_brackets = False\n                reversed_fixed_source_lines.append(line + \"]\")\n            else:\n                reversed_fixed_source_lines.append(line)\n\n        return \"\\n\".join(reversed(reversed_fixed_source_lines))\n\n    @staticmethod\n    def _fix_truthy_strings(source_code: str) -&gt; str:\n\"\"\"Convert common strings that refer to booleans.\n\n        All caps variations of true, yes and on are transformed to true, while false,\n        no and off are transformed to false.\n\n        Ruyaml understands these strings and converts them to the lower version of\n        the word instead of converting them to true and false.\n\n        [More info](https://yamllint.readthedocs.io/en/stable/rules.html#module-yamllint.rules.truthy) # noqa: E501\n\n        Args:\n            source_code: Source code to be corrected.\n\n        Returns:\n            Corrected source code.\n        \"\"\"\n        log.debug(\"Fixing truthy strings...\")\n        source_lines = source_code.splitlines()\n        fixed_source_lines: List[str] = []\n\n        for line in source_lines:\n            line_contains_true = re.match(\n                r\"(?P&lt;pre_boolean_text&gt;.*(:|-) )(true|yes|on)$\", line, re.IGNORECASE\n            )\n            line_contains_false = re.match(\n                r\"(?P&lt;pre_boolean_text&gt;.*(:|-) )(false|no|off)$\", line, re.IGNORECASE\n            )\n\n            if line_contains_true:\n                fixed_source_lines.append(\n                    f\"{line_contains_true.groupdict()['pre_boolean_text']}true\"\n                )\n            elif line_contains_false:\n                fixed_source_lines.append(\n                    f\"{line_contains_false.groupdict()['pre_boolean_text']}false\"\n                )\n            else:\n                fixed_source_lines.append(line)\n\n        return \"\\n\".join(fixed_source_lines)\n\n    @staticmethod\n    def _restore_truthy_strings(source_code: str) -&gt; str:\n\"\"\"Restore truthy strings to strings.\n\n        The Ruyaml parser removes the apostrophes of all the caps variations of\n        the strings 'yes', 'on', no and 'off' as it interprets them as booleans.\n\n        As this function is run after _fix_truthy_strings, those strings are\n        meant to be strings. So we're turning them back from booleans to strings.\n\n        Args:\n            source_code: Source code to be corrected.\n\n        Returns:\n            Corrected source code.\n        \"\"\"\n        log.debug(\"Restoring truthy strings...\")\n        source_lines = source_code.splitlines()\n        fixed_source_lines: List[str] = []\n\n        for line in source_lines:\n            line_contains_valid_truthy_string = re.match(\n                r\"(?P&lt;pre_boolean_text&gt;.*(:|-) )(?P&lt;boolean_text&gt;yes|on|no|off)$\",\n                line,\n                re.IGNORECASE,\n            )\n            if line_contains_valid_truthy_string:\n                fixed_source_lines.append(\n                    f\"{line_contains_valid_truthy_string.groupdict()['pre_boolean_text']}\"  # noqa: E501\n                    f\"'{line_contains_valid_truthy_string.groupdict()['boolean_text']}'\"\n                )\n            else:\n                fixed_source_lines.append(line)\n\n        return \"\\n\".join(fixed_source_lines)\n\n    def _fix_comments(self, source_code: str) -&gt; str:\n        log.debug(\"Fixing comments...\")\n        config = self.config\n        comment_start = \" \" * config.comments_min_spaces_from_content + \"#\"\n\n        fixed_source_lines = []\n\n        for line in source_code.splitlines():\n            # Comment at the start of the line\n            if config.comments_require_starting_space and re.search(r\"(^|\\s)#\\w\", line):\n                line = line.replace(\"#\", \"# \")\n            # Comment in the middle of the line, but it's not part of a string\n            if (\n                config.comments_min_spaces_from_content &gt; 1\n                and \" #\" in line\n                and line[-1] not in [\"'\", '\"']\n            ):\n                line = re.sub(r\"(.+\\S)(\\s+?)#\", rf\"\\1{comment_start}\", line)\n            fixed_source_lines.append(line)\n\n        return \"\\n\".join(fixed_source_lines)\n\n    def _fix_whitelines(self, source_code: str) -&gt; str:\n\"\"\"Fixes number of consecutive whitelines.\n\n        Before a line that only includes a comment, either:\n          - 0 whiteline is allowed\n          - Exactly `self.config.comments_whitelines` whitelines are allowed\n\n        This method removes extraneous whitelines that are not immediately followed by\n        a comment.\n\n        Args:\n            self: Source code to be corrected.\n\n        Returns:\n            Source code with appropriate whitelines standards.\n        \"\"\"\n        config = self.config\n        n_whitelines_from_content = config.comments_whitelines\n\n        re_whitelines_with_comments = \"\\n\\n+[\\t ]{0,}[#]\"\n        re_whitelines_with_no_comments = \"\\n\\n+[\\t ]{0,}[^#\\n\\t ]\"\n\n        remove_whitelines = partial(self._replace_whitelines, n_whitelines=0)\n        replace_by_n_whitelines = partial(\n            self._replace_whitelines,\n            n_whitelines=n_whitelines_from_content,\n        )\n\n        source_code = re.sub(\n            pattern=re_whitelines_with_no_comments,\n            repl=remove_whitelines,\n            string=source_code,\n        )\n        source_code = self._fix_section_whitelines(source_code)\n        source_code = re.sub(\n            pattern=re_whitelines_with_comments,\n            repl=replace_by_n_whitelines,\n            string=source_code,\n        )\n\n        return source_code\n\n    @staticmethod\n    def _replace_whitelines(match: Match[str], n_whitelines: int) -&gt; str:\n\"\"\"Replaces whitelines by a fixed number, `n_whitelines`, of whitelines.\n\n        Method used by `SourceCodeFixer._fix_whitelines()` to replace whitelines when\n        whitelines are not followed by a comment.\n\n        Args:\n            match: The matched expression by the regex module, `re`\n            n_whitelines: Desired number of whitelines to use to replace all leading\n            whitelines in `match`\n\n        Returns:\n            A string corresponding to the matched string with its leading whitelines\n            replaced by `n_whitelines` whitelines.\n        \"\"\"\n        matched_str = match.group()\n        adjusted_matched_str = \"\\n\" * (n_whitelines + 1) + matched_str.lstrip(\"\\n\")\n\n        return adjusted_matched_str\n\n    def _fix_section_whitelines(self, source_code: str) -&gt; str:\n        re_section = \"\\n*(^#.*\\n)*\\n*^[^ ].*:\\n(\\n|(^  .*))+\\n*\"\n        # Match the first --- or start of the string \\A\n        # See: https://docs.python.org/3.9/library/re.html#regular-expression-syntax\n        re_beginning_section = f\"(?P&lt;b&gt;(?:---\\n|\\\\A){re_section})\"\n        re_normal_section = f\"(?P&lt;s&gt;{re_section})\"\n        re_full = f\"{re_beginning_section}|{re_normal_section}\"\n        pattern = re.compile(re_full, flags=re.MULTILINE)\n\n        def _fix_before_section(match: Match[str]) -&gt; str:\n            section = match.group(\"s\")\n            if not section:\n                return match.group()\n            while section[0] == \"\\n\":\n                section = section[1:]\n            out = \"\\n\" * (self.config.section_whitelines + 1) + section\n            return out\n\n        def _fix_after_section(match: Match[str]) -&gt; str:\n            section = match.group(\"b\") or match.group(\"s\")\n            while section[-1] == \"\\n\":\n                section = section[:-1]\n            return section + \"\\n\" * (self.config.section_whitelines + 1)\n\n        before_fixed = pattern.sub(repl=_fix_before_section, string=source_code)\n        after_fixed = pattern.sub(repl=_fix_after_section, string=before_fixed)\n        while after_fixed[-2:] == \"\\n\\n\":\n            after_fixed = after_fixed[:-1]\n        return after_fixed\n\n    @staticmethod\n    def _restore_double_exclamations(source_code: str) -&gt; str:\n\"\"\"Restore the double exclamation marks.\n\n        The Ruyaml parser transforms the !!python statement to !%21python which breaks\n        some programs.\n        \"\"\"\n        log.debug(\"Restoring double exclamations...\")\n        fixed_source_lines = []\n        double_exclamation = re.compile(r\"!%21\")\n\n        for line in source_code.splitlines():\n            if double_exclamation.search(line):\n                line = line.replace(r\"!%21\", \"!!\")\n            fixed_source_lines.append(line)\n\n        return \"\\n\".join(fixed_source_lines)\n\n    @staticmethod\n    def _add_newline_at_end_of_file(source_code: str) -&gt; str:\n        return source_code + \"\\n\"\n\n    @staticmethod\n    def _fix_jinja_variables(source_code: str) -&gt; str:\n\"\"\"Remove spaces between jinja variables.\n\n        So that they are not split in many lines by ruyaml\n\n        Args:\n            source_code: Source code to be corrected.\n\n        Returns:\n            Corrected source code.\n        \"\"\"\n        log.debug(\"Fixing jinja2 variables...\")\n        source_lines = source_code.splitlines()\n        fixed_source_lines: List[str] = []\n\n        for line in source_lines:\n            line_contains_jinja2_variable = re.search(r\"{{.*}}\", line)\n\n            if line_contains_jinja2_variable:\n                line = SourceCodeFixer._encode_jinja2_line(line)\n\n            fixed_source_lines.append(line)\n\n        return \"\\n\".join(fixed_source_lines)\n\n    @staticmethod\n    def _encode_jinja2_line(line: str) -&gt; str:\n\"\"\"Encode jinja variables so that they are not split.\n\n        Using a special character to join the elements inside the {{ }}, so that\n        they are all taken as the same word, and ruyamel doesn't split them.\n        \"\"\"\n        new_line = []\n        variable_terms: List[str] = []\n\n        for word in line.split(\" \"):\n            if re.search(\"}}\", word):\n                variable_terms.append(word)\n                new_line.append(\"\u2605\".join(variable_terms))\n                variable_terms = []\n            elif re.search(\"{{\", word) or len(variable_terms) &gt; 0:\n                variable_terms.append(word)\n            else:\n                new_line.append(word)\n\n        return \" \".join(new_line)\n\n    @staticmethod\n    def _restore_jinja_variables(source_code: str) -&gt; str:\n\"\"\"Restore the jinja2 variables to their original state.\n\n        Remove the encoding introduced by _fix_jinja_variables to prevent ruyaml\n        to split the variables.\n        \"\"\"\n        log.debug(\"Restoring jinja2 variables...\")\n        fixed_source_lines = []\n\n        for line in source_code.splitlines():\n            line_contains_jinja2_variable = re.search(r\"{{.*}}\", line)\n\n            if line_contains_jinja2_variable:\n                line = line.replace(\"\u2605\", \" \")\n\n            fixed_source_lines.append(line)\n\n        return \"\\n\".join(fixed_source_lines)\n</code></pre>"},{"location":"reference/#yamlfix.adapters.SourceCodeFixer.__init__","title":"<code>__init__(yaml, config)</code>","text":"<p>Initialize the source code fixer adapter with a configured yaml fixer             instance and optional yamlfix config.</p> <p>Parameters:</p> Name Type Description Default <code>yaml</code> <code>Yaml</code> <p>Initialized Ruamel formatter to use for source code correction.</p> required <code>config</code> <code>Optional[YamlfixConfig]</code> <p>Small set of user provided configuration options for yamlfix.</p> required Source code in <code>yamlfix/adapters.py</code> <pre><code>def __init__(self, yaml: Yaml, config: Optional[YamlfixConfig]) -&gt; None:\n\"\"\"Initialize the source code fixer adapter with a configured yaml fixer \\\n        instance and optional yamlfix config.\n\n    Args:\n        yaml: Initialized Ruamel formatter to use for source code correction.\n        config: Small set of user provided configuration options for yamlfix.\n    \"\"\"\n    self.yaml = yaml.yaml\n    self.config = config or YamlfixConfig()\n</code></pre>"},{"location":"reference/#yamlfix.adapters.SourceCodeFixer.fix","title":"<code>fix(source_code)</code>","text":"<p>Run all yaml source code fixers.</p> <p>Parameters:</p> Name Type Description Default <code>source_code</code> <code>str</code> <p>Source code to be corrected.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Corrected source code.</p> Source code in <code>yamlfix/adapters.py</code> <pre><code>def fix(self, source_code: str) -&gt; str:\n\"\"\"Run all yaml source code fixers.\n\n    Args:\n        source_code: Source code to be corrected.\n\n    Returns:\n        Corrected source code.\n    \"\"\"\n    log.debug(\"Running source code fixers...\")\n\n    fixers = [\n        self._fix_truthy_strings,\n        self._fix_jinja_variables,\n        self._ruamel_yaml_fixer,\n        self._restore_truthy_strings,\n        self._restore_jinja_variables,\n        self._restore_double_exclamations,\n        self._fix_comments,\n        self._fix_whitelines,\n        self._fix_top_level_lists,\n        self._fix_flow_style_lists,\n        self._add_newline_at_end_of_file,\n    ]\n\n    for fixer in fixers:\n        source_code = fixer(source_code)\n\n    return source_code\n</code></pre>"},{"location":"reference/#yamlfix.adapters.Yaml","title":"<code>Yaml</code>","text":"<p>Adapter that holds the configured ruaml yaml fixer.</p> Source code in <code>yamlfix/adapters.py</code> <pre><code>class Yaml:\n\"\"\"Adapter that holds the configured ruaml yaml fixer.\"\"\"\n\n    def __init__(self, config: Optional[YamlfixConfig]) -&gt; None:\n\"\"\"Initialize the yaml adapter with an optional yamlfix config.\n\n        Args:\n            config: Small set of user provided configuration options for yamlfix.\n        \"\"\"\n        self.yaml = YAML()\n        self.config = config or YamlfixConfig()\n\n        # we have to call setattr with the string value, because the internal ruyaml\n        # implementation does the same thing and does not expose the attribute itself\n        setattr(  # noqa: B010\n            self.yaml,\n            \"_representer\",\n            YamlfixRepresenter(\n                self.config,\n                self.yaml.default_style,\n                self.yaml.default_flow_style,\n                self.yaml,\n            ),\n        )\n\n        self._base_configuration()\n\n    def _base_configuration(self) -&gt; None:\n\"\"\"Configure base settings for Ruamel's yaml.\"\"\"\n        log.debug(\"Running ruamel yaml base configuration...\")\n        config = self.config\n\n        # Configure YAML formatter\n        self.yaml.indent(\n            mapping=config.indent_mapping,\n            sequence=config.indent_sequence,\n            offset=config.indent_offset,\n        )\n        self.yaml.allow_duplicate_keys = config.allow_duplicate_keys\n\n        # Start the document with ---\n        # ignore: variable has type None, what can we do, it doesn't have type hints...\n        self.yaml.explicit_start = config.explicit_start  # type: ignore\n        self.yaml.width = config.line_length  # type: ignore\n</code></pre>"},{"location":"reference/#yamlfix.adapters.Yaml.__init__","title":"<code>__init__(config)</code>","text":"<p>Initialize the yaml adapter with an optional yamlfix config.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Optional[YamlfixConfig]</code> <p>Small set of user provided configuration options for yamlfix.</p> required Source code in <code>yamlfix/adapters.py</code> <pre><code>def __init__(self, config: Optional[YamlfixConfig]) -&gt; None:\n\"\"\"Initialize the yaml adapter with an optional yamlfix config.\n\n    Args:\n        config: Small set of user provided configuration options for yamlfix.\n    \"\"\"\n    self.yaml = YAML()\n    self.config = config or YamlfixConfig()\n\n    # we have to call setattr with the string value, because the internal ruyaml\n    # implementation does the same thing and does not expose the attribute itself\n    setattr(  # noqa: B010\n        self.yaml,\n        \"_representer\",\n        YamlfixRepresenter(\n            self.config,\n            self.yaml.default_style,\n            self.yaml.default_flow_style,\n            self.yaml,\n        ),\n    )\n\n    self._base_configuration()\n</code></pre>"},{"location":"reference/#yamlfix.adapters.YamlfixRepresenter","title":"<code>YamlfixRepresenter</code>","text":"<p>         Bases: <code>RoundTripRepresenter</code></p> <p>Yamlfix's custom implementation of the ruyaml.RoundTripRepresenter        that can be configured with YamlfixConfig.</p> Source code in <code>yamlfix/adapters.py</code> <pre><code>class YamlfixRepresenter(RoundTripRepresenter):\n\"\"\"Yamlfix's custom implementation of the ruyaml.RoundTripRepresenter\\\n        that can be configured with YamlfixConfig.\"\"\"\n\n    def __init__(\n        self,\n        config: YamlfixConfig,\n        default_style: Optional[str] = None,\n        default_flow_style: Optional[bool] = None,\n        dumper: Optional[YAML] = None,\n    ) -&gt; None:\n\"\"\"Initialize the YamlfixRepresenter and its parent RoundTripRepresenter.\"\"\"\n        RoundTripRepresenter.__init__(\n            self,\n            default_style=default_style,\n            default_flow_style=default_flow_style,\n            dumper=dumper,\n        )\n\n        self.config: YamlfixConfig = config\n        self.patch_functions: List[Callable[[Node, Node], None]] = []\n\n        configure_patch_functions = [\n            self._configure_quotation_for_basic_values,\n            self._configure_sequence_style,\n        ]\n\n        for patch_configurer in configure_patch_functions:\n            patch_configurer()\n\n    def represent_none(self, data: Any) -&gt; ScalarNode:  # noqa: ANN401\n\"\"\"Configure how Ruamel's yaml represents None values.\n\n        Default is an empty representation, could be overridden by canonical values\n        like \"~\", \"null\", \"NULL\"\n        \"\"\"\n        if (\n            self.config.none_representation is None\n            or self.config.none_representation == \"\"\n        ):\n            return super().represent_none(data)\n\n        return self.represent_scalar(\n            \"tag:yaml.org,2002:null\", self.config.none_representation\n        )\n\n    def represent_str(self, data: Any) -&gt; ScalarNode:  # noqa: ANN401\n\"\"\"Configure Ruamel's yaml fixer to quote all yaml keys and simple* string values.\n\n        Simple string values meaning: No multi line strings, as they are represented\n        by LiteralScalarStrings instead.\n        \"\"\"\n        if (\n            not self.config.quote_keys_and_basic_values\n            or self.config.quote_representation is None\n        ):\n            return super().represent_str(data)\n\n        return self.represent_scalar(\n            \"tag:yaml.org,2002:str\", data, self.config.quote_representation\n        )\n\n    def represent_mapping(\n        self, tag: Any, mapping: Any, flow_style: Optional[Any] = None  # noqa: ANN401\n    ) -&gt; MappingNode:\n\"\"\"Modify / Patch the original ruyaml representer represent_mapping value and\\\n            call the provided patch_function on its mapping_values.\"\"\"\n        mapping_node: MappingNode = super().represent_mapping(tag, mapping, flow_style)\n        mapping_values: List[Tuple[ScalarNode, Node]] = mapping_node.value\n\n        if isinstance(mapping_values, list):\n            for mapping_value in mapping_values:\n                if isinstance(mapping_value, tuple):\n                    key_node: Node = mapping_value[0]\n                    value_node: Node = mapping_value[1]\n                    for patch_function in self.patch_functions:\n                        patch_function(key_node, value_node)\n\n        return mapping_node\n\n    def _configure_quotation_for_basic_values(self) -&gt; None:\n\"\"\"Configure Ruamel's yaml fixer to quote only simple* yaml string values.\n\n        Simple string values meaning: Any string that does not already have an\n        explicit 'style' applied already -&gt; multi line strings have a style value\n        of \"|\" per default.\n        \"\"\"\n        config = self.config\n        log.debug(\"Setting up ruamel yaml 'quote simple values' configuration...\")\n\n        def patch_quotations(key_node: Node, value_node: Node) -&gt; None:  # noqa: W0613\n            if not config.quote_basic_values or config.quote_representation is None:\n                return\n\n            # if this is a scalar value node itself, apply the quotations now\n            self._apply_simple_value_quotations(value_node)\n\n            # if this is a sequence value node, check for value presence, complex\n            # sequences and apply quotations to its values\n            if not isinstance(value_node, SequenceNode) or value_node.value is None:\n                return\n\n            sequence_node: SequenceNode = value_node\n\n            if self._seq_contains_non_scalar_nodes(\n                sequence_node\n            ) or self._seq_contains_non_empty_comments(sequence_node):\n                return\n\n            for seq_value in sequence_node.value:\n                self._apply_simple_value_quotations(seq_value)\n\n        self.patch_functions.append(patch_quotations)\n\n    def _configure_sequence_style(self) -&gt; None:\n\"\"\"Configure Ruamel's yaml fixer to represent lists as either block-style \\\n            or flow-style.\n\n        Also make sure, that lists containing non-scalar values (other maps, \\\n            lists), lists that contain comments and lists that would breach the\n            line-length are forced to block-style, regardless of configuration.\n\n        Lists in block-style look like this:\n        ```\n        list:\n          # Comment for item\n          - item\n          - item\n          - complex_item:\n              # Comment for key\n              key: value\n        ```\n\n        Lists in flow-style look like this, we do not convert lists with complex\n        values or lists with comments to that style, it is meant for simple lists,\n        that contain only scalar values (string, int, bool, etc.) not other complex\n        values (lists, dicts, comments, etc.)\n        ```\n        list: [item, item, item]\n        ```\n\n        Empty lists are not handled well in either style, so they are skipped as well,\n        as you can only represent empty lists in flow-style either way.\n        \"\"\"\n        config = self.config\n        log.debug(\"Setting up ruamel yaml 'sequence flow style' configuration...\")\n\n        def patch_sequence_style(key_node: Node, value_node: Node) -&gt; None:\n            if isinstance(key_node, ScalarNode) and isinstance(\n                value_node, SequenceNode\n            ):\n                # don't modify the sequence style at all, if the config value is\n                # set to `keep_style`\n                if config.sequence_style == YamlNodeStyle.KEEP_STYLE:\n                    return\n\n                force_block_style: bool = False\n                sequence_node: SequenceNode = value_node\n\n                # check if the sequence node value is present and if it is not empty\n                if not sequence_node.value:\n                    return\n\n                # if this sequence contains non-scalar nodes (i.e. dicts, lists, etc.),\n                # force block-style\n                force_block_style = (\n                    force_block_style\n                    or self._seq_contains_non_scalar_nodes(sequence_node)\n                )\n\n                # if this sequence contains non-empty comments, force block-style\n                force_block_style = (\n                    force_block_style\n                    or self._seq_contains_non_empty_comments(sequence_node)\n                )\n\n                # if this sequence, rendered in flow-style would breach the line-width,\n                # force block-style roughly calculate the consumed width, in any case\n                # ruyaml will fold flow-style lists if they breach the limit only\n                # consider scalars, as non-scalar nodes should force block-style already\n                force_block_style = (\n                    force_block_style\n                    or self._seq_length_longer_than_line_length(key_node, sequence_node)\n                )\n\n                sequence_node.flow_style = (\n                    config.sequence_style == YamlNodeStyle.FLOW_STYLE\n                )\n                if force_block_style:\n                    sequence_node.flow_style = False\n\n        self.patch_functions.append(patch_sequence_style)\n\n    @staticmethod\n    def _seq_contains_non_scalar_nodes(seq_node: Node) -&gt; bool:\n        return any(not isinstance(node, ScalarNode) for node in seq_node.value)\n\n    @staticmethod\n    def _seq_contains_non_empty_comments(seq_node: Node) -&gt; bool:\n        comment_tokens: List[CommentToken] = []\n\n        for node in seq_node.value:\n            if isinstance(node, ScalarNode) and isinstance(node.comment, list):\n                comment_tokens.extend(node.comment)\n\n        return any(\n            isinstance(comment_token, CommentToken)\n            and comment_token.value.strip() != \"\"\n            for comment_token in comment_tokens\n        )\n\n    def _seq_length_longer_than_line_length(\n        self, key_node: Node, seq_node: Node\n    ) -&gt; bool:\n        config = self.config\n\n        # This could be made configurable, or rather we could calculate if we need\n        # the quotation spaces for the configured settings, but if we err on the\n        # side of caution we can always force block-mode even for values that could\n        # technically, without quotes, fit into the line-length\n\n        # quotation marks around scalar value\n        quote_length: int = 2\n\n        # comma and space between scalar values or colon and space\n        # between key + values\n        separator_length: int = 2\n\n        # opening and closing brackets that should fit on the same line\n        bracket_length: int = 2\n\n        key_length: int = len(str(key_node.value)) + quote_length + separator_length\n\n        scalar_length: int = 0\n\n        for node in seq_node.value:\n            if isinstance(node, ScalarNode):\n                scalar_length += len(str(node.value)) + quote_length + separator_length\n\n        if key_length + scalar_length + bracket_length &gt; config.line_length:\n            return True\n\n        return False\n\n    def _apply_simple_value_quotations(self, value_node: Node) -&gt; None:\n        if (\n            isinstance(value_node, ScalarNode)\n            and value_node.tag == \"tag:yaml.org,2002:str\"\n            and value_node.style is None\n        ):\n            value_node.style = self.config.quote_representation\n</code></pre>"},{"location":"reference/#yamlfix.adapters.YamlfixRepresenter.__init__","title":"<code>__init__(config, default_style=None, default_flow_style=None, dumper=None)</code>","text":"<p>Initialize the YamlfixRepresenter and its parent RoundTripRepresenter.</p> Source code in <code>yamlfix/adapters.py</code> <pre><code>def __init__(\n    self,\n    config: YamlfixConfig,\n    default_style: Optional[str] = None,\n    default_flow_style: Optional[bool] = None,\n    dumper: Optional[YAML] = None,\n) -&gt; None:\n\"\"\"Initialize the YamlfixRepresenter and its parent RoundTripRepresenter.\"\"\"\n    RoundTripRepresenter.__init__(\n        self,\n        default_style=default_style,\n        default_flow_style=default_flow_style,\n        dumper=dumper,\n    )\n\n    self.config: YamlfixConfig = config\n    self.patch_functions: List[Callable[[Node, Node], None]] = []\n\n    configure_patch_functions = [\n        self._configure_quotation_for_basic_values,\n        self._configure_sequence_style,\n    ]\n\n    for patch_configurer in configure_patch_functions:\n        patch_configurer()\n</code></pre>"},{"location":"reference/#yamlfix.adapters.YamlfixRepresenter.represent_mapping","title":"<code>represent_mapping(tag, mapping, flow_style=None)</code>","text":"<p>Modify / Patch the original ruyaml representer represent_mapping value and            call the provided patch_function on its mapping_values.</p> Source code in <code>yamlfix/adapters.py</code> <pre><code>def represent_mapping(\n    self, tag: Any, mapping: Any, flow_style: Optional[Any] = None  # noqa: ANN401\n) -&gt; MappingNode:\n\"\"\"Modify / Patch the original ruyaml representer represent_mapping value and\\\n        call the provided patch_function on its mapping_values.\"\"\"\n    mapping_node: MappingNode = super().represent_mapping(tag, mapping, flow_style)\n    mapping_values: List[Tuple[ScalarNode, Node]] = mapping_node.value\n\n    if isinstance(mapping_values, list):\n        for mapping_value in mapping_values:\n            if isinstance(mapping_value, tuple):\n                key_node: Node = mapping_value[0]\n                value_node: Node = mapping_value[1]\n                for patch_function in self.patch_functions:\n                    patch_function(key_node, value_node)\n\n    return mapping_node\n</code></pre>"},{"location":"reference/#yamlfix.adapters.YamlfixRepresenter.represent_none","title":"<code>represent_none(data)</code>","text":"<p>Configure how Ruamel's yaml represents None values.</p> <p>Default is an empty representation, could be overridden by canonical values like \"~\", \"null\", \"NULL\"</p> Source code in <code>yamlfix/adapters.py</code> <pre><code>def represent_none(self, data: Any) -&gt; ScalarNode:  # noqa: ANN401\n\"\"\"Configure how Ruamel's yaml represents None values.\n\n    Default is an empty representation, could be overridden by canonical values\n    like \"~\", \"null\", \"NULL\"\n    \"\"\"\n    if (\n        self.config.none_representation is None\n        or self.config.none_representation == \"\"\n    ):\n        return super().represent_none(data)\n\n    return self.represent_scalar(\n        \"tag:yaml.org,2002:null\", self.config.none_representation\n    )\n</code></pre>"},{"location":"reference/#yamlfix.adapters.YamlfixRepresenter.represent_str","title":"<code>represent_str(data)</code>","text":"<p>Configure Ruamel's yaml fixer to quote all yaml keys and simple* string values.</p> <p>Simple string values meaning: No multi line strings, as they are represented by LiteralScalarStrings instead.</p> Source code in <code>yamlfix/adapters.py</code> <pre><code>def represent_str(self, data: Any) -&gt; ScalarNode:  # noqa: ANN401\n\"\"\"Configure Ruamel's yaml fixer to quote all yaml keys and simple* string values.\n\n    Simple string values meaning: No multi line strings, as they are represented\n    by LiteralScalarStrings instead.\n    \"\"\"\n    if (\n        not self.config.quote_keys_and_basic_values\n        or self.config.quote_representation is None\n    ):\n        return super().represent_str(data)\n\n    return self.represent_scalar(\n        \"tag:yaml.org,2002:str\", data, self.config.quote_representation\n    )\n</code></pre>"},{"location":"reference/#yamlfix.config","title":"<code>yamlfix.config</code>","text":"<p>Define the configuration of the main program.</p>"},{"location":"reference/#yamlfix.config.configure_yamlfix","title":"<code>configure_yamlfix(yamlfix_config, config_files=None, additional_config=None)</code>","text":"<p>Configure the YamlfixConfig object from .toml/.ini configuration files         and additional config overrides.</p> Source code in <code>yamlfix/config.py</code> <pre><code>def configure_yamlfix(\n    yamlfix_config: YamlfixConfig,\n    config_files: Optional[List[str]] = None,\n    additional_config: Optional[Dict[str, str]] = None,\n) -&gt; None:\n\"\"\"Configure the YamlfixConfig object from .toml/.ini configuration files \\\n        and additional config overrides.\"\"\"\n    config_path: Optional[Path] = None\n\n    if additional_config:\n        config_path_env: Optional[str] = additional_config.get(\"config_path\", None)\n        if config_path_env:\n            config_path = Path(config_path_env)\n\n    config: ProjectConfig = ProjectConfig(\n        config_schema=YamlfixConfig,\n        merge_configs=True,\n        project_name=\"yamlfix\",\n        source_files=config_files,\n        starting_path=config_path,\n    )\n    config_dict: Dict[str, Any] = config.to_dict()\n\n    if additional_config:\n        for override_key, override_val in additional_config.items():\n            config_dict[override_key] = override_val\n\n    config.validate()\n    config_dict = config.to_dict()\n\n    for config_key, config_val in config_dict.items():\n        setattr(yamlfix_config, config_key, config_val)\n</code></pre>"},{"location":"reference/#yamlfix.entrypoints","title":"<code>yamlfix.entrypoints</code>","text":"<p>Define the different ways to expose the program functionality.</p> Functions"},{"location":"reference/#yamlfix.entrypoints.ANSIFGColorCode","title":"<code>ANSIFGColorCode</code>","text":"<p>         Bases: <code>Enum</code></p> <p>ANSI escape codes for colored output.</p> Source code in <code>yamlfix/entrypoints/__init__.py</code> <pre><code>class ANSIFGColorCode(Enum):\n\"\"\"ANSI escape codes for colored output.\"\"\"\n\n    BLACK = 30\n    RED = 31\n    GREEN = 32\n    YELLOW = 33\n    BLUE = 34\n    MAGENTA = 35\n    CYAN = 36\n    WHITE = 37\n    RESET = 0\n</code></pre>"},{"location":"reference/#yamlfix.entrypoints.ConsoleColorFormatter","title":"<code>ConsoleColorFormatter</code>","text":"<p>         Bases: <code>logging.Formatter</code></p> <p>Custom formatter that prints log levels to the console as colored plus signs.</p> Source code in <code>yamlfix/entrypoints/__init__.py</code> <pre><code>class ConsoleColorFormatter(logging.Formatter):\n\"\"\"Custom formatter that prints log levels to the console as colored plus signs.\"\"\"\n\n    # ANSI escape codes for colored output\n    colors = {\n        logging.DEBUG: ANSIFGColorCode.WHITE,\n        # There are only 2 named levels under WARNING, we need 3 levels of verbosity\n        # Using half-way between DEBUG and INFO as additional verbosity level\n        # It is currently used for logging unchanged files\n        15: ANSIFGColorCode.GREEN,\n        logging.INFO: ANSIFGColorCode.CYAN,\n        logging.WARNING: ANSIFGColorCode.YELLOW,\n        logging.ERROR: ANSIFGColorCode.RED,\n    }\n\n    def format(self, record: logging.LogRecord) -&gt; str:\n\"\"\"Format log records as a colored plus sign followed by the log message.\"\"\"\n        color = self.colors.get(record.levelno, ANSIFGColorCode.RESET)\n        self._style._fmt = f\"[\\033[{color.value}m+\\033[0m] %(message)s\"  # noqa: W0212\n        return super().format(record)\n</code></pre>"},{"location":"reference/#yamlfix.entrypoints.ConsoleColorFormatter.format","title":"<code>format(record)</code>","text":"<p>Format log records as a colored plus sign followed by the log message.</p> Source code in <code>yamlfix/entrypoints/__init__.py</code> <pre><code>def format(self, record: logging.LogRecord) -&gt; str:\n\"\"\"Format log records as a colored plus sign followed by the log message.\"\"\"\n    color = self.colors.get(record.levelno, ANSIFGColorCode.RESET)\n    self._style._fmt = f\"[\\033[{color.value}m+\\033[0m] %(message)s\"  # noqa: W0212\n    return super().format(record)\n</code></pre>"},{"location":"reference/#yamlfix.entrypoints.load_logger","title":"<code>load_logger(verbose=0)</code>","text":"<p>Configure the Logging logger.</p> <p>Parameters:</p> Name Type Description Default <code>verbose</code> <code>int</code> <p>Allow more detailed logging output.</p> <code>0</code> Source code in <code>yamlfix/entrypoints/__init__.py</code> <pre><code>def load_logger(verbose: int = 0) -&gt; None:\n\"\"\"Configure the Logging logger.\n\n    Args:\n        verbose: Allow more detailed logging output.\n    \"\"\"\n    log_level = logging.INFO - verbose * 5\n    logging.basicConfig(stream=sys.stderr, level=log_level)\n    for handler in logging.getLogger().handlers:\n        handler.setFormatter(ConsoleColorFormatter())\n</code></pre>"},{"location":"reference/#yamlfix.model","title":"<code>yamlfix.model</code>","text":"<p>Define program entities like configuration value entities.</p>"},{"location":"reference/#yamlfix.model.YamlNodeStyle","title":"<code>YamlNodeStyle</code>","text":"<p>         Bases: <code>Enum</code></p> <p>Represent the desired YAML node style for sequences and mappings.</p> Source code in <code>yamlfix/model.py</code> <pre><code>class YamlNodeStyle(Enum):\n\"\"\"Represent the desired YAML node style for sequences and mappings.\"\"\"\n\n    FLOW_STYLE = \"flow_style\"\n    BLOCK_STYLE = \"block_style\"\n    KEEP_STYLE = \"keep_style\"\n</code></pre>"},{"location":"reference/#yamlfix.model.YamlfixConfig","title":"<code>YamlfixConfig</code>","text":"<p>         Bases: <code>ConfigSchema</code></p> <p>Configuration entity for yamlfix.</p> Source code in <code>yamlfix/model.py</code> <pre><code>class YamlfixConfig(ConfigSchema):\n\"\"\"Configuration entity for yamlfix.\"\"\"\n\n    allow_duplicate_keys: bool = False\n    comments_min_spaces_from_content: int = 2\n    comments_require_starting_space: bool = True\n    comments_whitelines: int = 1\n    section_whitelines: int = 0\n    config_path: Optional[str] = None\n    explicit_start: bool = True\n    indent_mapping: int = 2\n    indent_offset: int = 2\n    indent_sequence: int = 4\n    line_length: int = 80\n    none_representation: str = \"\"\n    quote_basic_values: bool = False\n    quote_keys_and_basic_values: bool = False\n    quote_representation: str = \"'\"\n    sequence_style: YamlNodeStyle = YamlNodeStyle.FLOW_STYLE\n</code></pre>"},{"location":"reference/#yamlfix.services","title":"<code>yamlfix.services</code>","text":"<p>Define all the orchestration functionality required by the program to work.</p> <p>Classes and functions that connect the different domain model objects with the adapters and handlers to achieve the program's purpose.</p>"},{"location":"reference/#yamlfix.services.fix_code","title":"<code>fix_code(source_code, config=None)</code>","text":"<p>Fix yaml source code to correct the format.</p> It corrects these errors <ul> <li>Add --- at the beginning of the file.</li> <li>Correct truthy strings: 'True' -&gt; true, 'no' -&gt; 'false'</li> <li>Remove unnecessary apostrophes: <code>title: 'Why we sleep'</code> -&gt;     <code>title: Why we sleep</code>.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>source_code</code> <code>str</code> <p>Source code to be corrected.</p> required <code>config</code> <code>Optional[YamlfixConfig]</code> <p>Small set of user provided configuration options for yamlfix.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>Corrected source code.</p> Source code in <code>yamlfix/services.py</code> <pre><code>def fix_code(source_code: str, config: Optional[YamlfixConfig] = None) -&gt; str:\n\"\"\"Fix yaml source code to correct the format.\n\n    It corrects these errors:\n\n        * Add --- at the beginning of the file.\n        * Correct truthy strings: 'True' -&gt; true, 'no' -&gt; 'false'\n        * Remove unnecessary apostrophes: `title: 'Why we sleep'` -&gt;\n            `title: Why we sleep`.\n\n    Args:\n        source_code: Source code to be corrected.\n        config: Small set of user provided configuration options for yamlfix.\n\n    Returns:\n        Corrected source code.\n    \"\"\"\n    # Leave Ansible vaults unmodified\n    if source_code.startswith(\"$ANSIBLE_VAULT;\"):\n        return source_code\n\n    if source_code.startswith(\"#!\"):\n        # Skip the shebang line if present, leaving it unmodified\n        eolpos = source_code.find(\"\\n\") + 1\n        shebang = source_code[:eolpos]\n        source_code = source_code[eolpos:]\n    else:\n        shebang = \"\"\n\n    yaml = Yaml(config=config)\n    fixer = SourceCodeFixer(yaml=yaml, config=config)\n\n    source_code = fixer.fix(source_code=source_code)\n\n    return shebang + source_code\n</code></pre>"},{"location":"reference/#yamlfix.services.fix_files","title":"<code>fix_files(files, dry_run=None, config=None)</code>","text":"<p>Fix the yaml source code of a list of files.</p> <p>If the input is taken from stdin, it will return the fixed value.</p> <p>Parameters:</p> Name Type Description Default <code>files</code> <code>Files</code> <p>List of files to fix.</p> required <code>dry_run</code> <code>Optional[bool]</code> <p>Whether to write changes or not.</p> <code>None</code> <code>config</code> <code>Optional[YamlfixConfig]</code> <p>Small set of user provided configuration options for yamlfix.</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Optional[str], Tuple[Optional[str], bool]]</code> <p>A tuple with the following items:</p> <code>Union[Optional[str], Tuple[Optional[str], bool]]</code> <ul> <li>Fixed code or None.</li> </ul> <code>Union[Optional[str], Tuple[Optional[str], bool]]</code> <ul> <li>A bool to indicate whether at least one file has been changed.</li> </ul> Source code in <code>yamlfix/services.py</code> <pre><code>def fix_files(  # pylint: disable=too-many-branches\n    files: Files, dry_run: Optional[bool] = None, config: Optional[YamlfixConfig] = None\n) -&gt; Union[Optional[str], Tuple[Optional[str], bool]]:  # noqa: TAE002\n\"\"\"Fix the yaml source code of a list of files.\n\n    If the input is taken from stdin, it will return the fixed value.\n\n    Args:\n        files: List of files to fix.\n        dry_run: Whether to write changes or not.\n        config: Small set of user provided configuration options for yamlfix.\n\n    Returns:\n        A tuple with the following items:\n        * Fixed code or None.\n        * A bool to indicate whether at least one file has been changed.\n    \"\"\"\n    changed = False\n\n    if dry_run is None:\n        warnings.warn(\n\"\"\"\n            From 2023-01-12 fix_files will change the return type from\n            `Optional[str]` to Tuple[Optional[str], bool], where the first\n            element of the Tuple is the fixed source and the second a bool that\n            returns whether the source has changed.\n\n            For more information check https://github.com/lyz-code/yamlfix/pull/182\n            \"\"\",\n            UserWarning,\n        )\n\n    total_fixed = 0\n\n    for file_ in files:\n        if isinstance(file_, str):\n            with open(file_, \"r\", encoding=\"utf-8\") as file_descriptor:\n                source = file_descriptor.read()\n                file_name = file_\n        else:\n            source = file_.read()\n            file_name = file_.name\n\n        log.debug(\"Fixing file %s...\", file_name)\n        fixed_source = fix_code(source, config)\n\n        if fixed_source != source:\n            changed = True\n            if dry_run:\n                log.info(\"Would fix %s\", file_name)\n            else:\n                log.info(\"Fixed %s\", file_name)\n                total_fixed += 1\n        else:\n            log.log(15, \"%s is already well formatted\", file_name)\n\n        if file_name == \"&lt;stdin&gt;\":\n            if dry_run is None:\n                return fixed_source\n            return fixed_source, changed\n\n        if fixed_source != source:\n            if dry_run:\n                continue\n            if isinstance(file_, str):\n                with open(file_, \"w\", encoding=\"utf-8\") as file_descriptor:\n                    file_descriptor.write(fixed_source)\n            else:\n                file_.seek(0)\n                file_.write(fixed_source)\n                file_.truncate()\n    log.info(\n        \"Checked %d files: %d fixed, %d left unchanged\",\n        len(files),\n        total_fixed,\n        len(files) - total_fixed,\n    )\n\n    if dry_run is None:\n        return None\n\n    return None, changed\n</code></pre>"},{"location":"reference/#yamlfix.version","title":"<code>yamlfix.version</code>","text":"<p>Utilities to retrieve the information of the program version.</p>"},{"location":"reference/#yamlfix.version.version_info","title":"<code>version_info()</code>","text":"<p>Display the version of the program, python and the platform.</p> Source code in <code>yamlfix/version.py</code> <pre><code>def version_info() -&gt; str:\n\"\"\"Display the version of the program, python and the platform.\"\"\"\n    return dedent(\n        f\"\"\"\\\n        ------------------------------------------------------------------\n             yamlfix: {__version__}\n             Python: {sys.version.split(\" \", maxsplit=1)[0]}\n             Platform: {platform.platform()}\n        ------------------------------------------------------------------\"\"\"\n    )\n</code></pre>"},{"location":"adr/adr/","title":"Adr","text":"<p>ADR are short text documents that captures an important architectural decision made along with its context and consequences.</p> <pre><code>graph TD\n    001[001: High level analysis]\n    002[002: Initial Program design]\n\n    001 -- Extended --&gt; 002\n\n    click 001 \"https://lyz-code.github.io/yamlfix/adr/001-high_level_problem_analysis\" _blank\n    click 002 \"https://lyz-code.github.io/yamlfix/adr/002-initial_program_design\" _blank\n\n    001:::draft\n    002:::draft\n\n    classDef draft fill:#CDBFEA;\n    classDef proposed fill:#B1CCE8;\n    classDef accepted fill:#B1E8BA;\n    classDef rejected fill:#E8B1B1;\n    classDef deprecated fill:#E8B1B1;\n    classDef superseeded fill:#E8E5B1;</code></pre>"}]}