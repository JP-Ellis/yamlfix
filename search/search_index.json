{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"A simple opinionated yaml formatter that keeps your comments! Installing \u00b6 pip install yamlfix Usage \u00b6 Imagine we've got the following source code: book_library : - title : Why we sleep author : Matthew Walker - title : Harry Potter and the Methods of Rationality author : Eliezer Yudkowsky It has the following errors: There is no --- at the top. The indentation is all wrong. After running yamlfix the resulting source code will be: book_library : - title : Why we sleep author : Matthew Walker - title : Harry Potter and the Methods of Rationality author : Eliezer Yudkowsky yamlfix can be used both as command line tool and as a library. As a command line tool: $: yamlfix file.yaml As a library: from yamlfix import fix_files fix_files ([ \"file.py\" ]) If instead of reading from a file you want to fix the code saved into a variable, use fix_code : from yamlfix import fix_code source_code = \"a: 1\" fixed_code = fix_code ( source_code ) assert fixed_code == \"--- \\n a: 1 \\n \" Features \u00b6 yamlfix will do the following changes in your yaml source code per default: Add the header --- to your file. Correct truthy strings : 'True' -> true, 'no' -> 'false' Remove unnecessary apostrophes: title: 'Why we sleep' -> title: Why we sleep . Correct comments Ensure that there is exactly one newline at the end of each file, to comply with the POSIX standard . Split long lines. Respect Jinja2 syntax. Ensure a \\n exists at the end of the file. Convert short lists to flow-style list: [item, item] Convert lists longer than line-width to block-style: list : - item - item Configuration \u00b6 yamlfix uses the maison library to find and parse configuration from standard locations, and can additionally be configured through environment variables. Any configuration found in the YamlfixConfig class can be set through your projects pyproject.toml , a custom toml -file or through the environment by providing an environment variable like {yamlfix_env_prefix}_{yamlfix_config_key} . Configuration options that are provided through environment variables have higher priority than options provided through configuration files and will override those keys. All provided configuration options , be it through pyproject.toml , config-files or env-vars, will be parsed by pydantic , so the target value type (str, bool, int, etc.) will be enforced, even if the provided value has the wrong type (for example all env vars in linux systems are strings, but pydantic will parse them to bools/numbers where necessary). Auto-Configure through pyproject.toml \u00b6 The maison library will automatically pick up your yamlfix configuration through your projects pyproject.toml . It will look in the section named tool.yamlfix and apply the provided configuration options . For example: # pyproject.toml [tool.yamlfix] allow_duplicate_keys = true line_length = 80 none_representation = \"null\" Provide config-files \u00b6 When running yamlfix as a standalone cli application it might be desireable to provide a config file containing just the configuration related to yamlfix . A cli-argument -c ( --config-file ) can be provided multiple times to read configuration values from toml formatted files. The rightmost value-files override the value-files preceding them, only trumped by environment variables. No section headers are necessary for these configuration files, as the expected behaviour is, that those files contain only configuration related to yamlfix . For example: # run yamlfix with two config files yamlfix -c base.toml --config-file environment.toml file.yaml # base.toml allow_duplicate_keys = false line_length = 100 # environment.toml allow_duplicate_keys = true These provided configuration files would result in a merged runtime-configuration of: # merged configuration allow_duplicate_keys = true line_length = 100 Configure environment prefix \u00b6 Per default yamlfix , when run through cli, will read any environment variable that starts with YAMLFIX_ and apply it to the merged runtime-configuration object. This default value can be overridden with the cli-parameter --env-prefix . For example: # set a configuration value with the default prefix export YAMLFIX_LINE_LENGTH = \"300\" # set a configuration value with the custom prefix export MY_PREFIX_NONE_REPRESENTATION = \"~\" # run yamlfix with a custom environment prefix yamlfix --env-prefix \"MY_PREFIX\" file.yaml These provided arguments and environment variables would result in a merged runtime-configuration of: # merged configuration # default value for line_length stays at: 80 none_representation = \"~\" Configuration Options \u00b6 All fields configured in the YamlfixConfig class can be provided through the means mentioned in Configuration . Here are the currently available configuration options with short examples on their impact to provided yaml -files. Allow Duplicate Keys \u00b6 Default: allow_duplicate_keys: bool = False Environment variable override: export YAMLFIX_ALLOW_DUPLICATE_KEYS = \"true\" This option toggles the ruyaml duplicate keys check . With this setting set to False , yamlfix will throw an error if the same key is defined more than once in a mapping / dictionary. To allow using the same key, set this value to True . You might want to enable this option, if you want to use multiple yaml-anchor merge keys, instead of providing them as sequence / list elements - see: https://github.com/pycontribs/ruyaml/issues/43 Comments Min Spaces From Content \u00b6 Default: comments_min_spaces_from_content: int = 2 Environment variable override: export YAMLFIX_COMMENTS_MIN_SPACES_FROM_CONTENT = \"2\" This option enforces minimum spacing between the content of a line and the start of an inline-comment. It is the enforcement implementation to the yamllint rule rules.comments.min-spaces-from-content - see: https://yamllint.readthedocs.io/en/stable/rules.html#module-yamllint.rules.comments Comments Require Starting Space \u00b6 Default: comments_require_starting_space: bool = True Environment variable override: export YAMLFIX_COMMENTS_REQUIRE_STARTING_SPACE = \"true\" This option enforces a space between the comment indicator ( # ) and the first character in the comment. It implements the enforcement of the yamllint rule rules.comments.require-starting-space - see: https://yamllint.readthedocs.io/en/stable/rules.html#module-yamllint.rules.comments Config Path \u00b6 Default: config_path: Optional[str] = None Environment variable override: export YAMLFIX_CONFIG_PATH = \"/etc/yamlfix/\" Configure the base config-path that maison will look for a pyproject.toml configuration file. This path is traversed upwards until such a file is found. Explicit Document Start \u00b6 Default: explicit_start: bool = True Environment variable override: export YAMLFIX_EXPLICIT_START = \"true\" Add or remove the explicit document start ( --- ) for yaml -files. For example: Set to true : --- project_name : yamlfix Set to false : project_name : yamlfix Sequence (List) Style \u00b6 Default: sequence_style: YamlNodeStyle = YamlNodeStyle.FLOW_STYLE Environment variable override: export YAMLFIX_SEQUENCE_STYLE = \"flow_style\" Available values: flow_style , block_style , keep_style Transform sequences (lists) to either flow-style, block-style or leave them as-is. If enabled yamlfix will also ensure, that flow-style lists are automatically converted to block-style if the resulting key+list elements would breach the line-length. For example: Set to true (flow-style): --- list : [ item , item , item ] Set to false (block-style): --- list : - item - item - item Indentation \u00b6 Default: indent_mapping: int = 2 indent_offset: int = 2 indent_sequence: int = 4 Environment variable override: export YAMLFIX_INDENT_MAPPING = \"2\" export YAMLFIX_INDENT_OFFSET = \"2\" export YAMLFIX_INDENT_SEQUENCE = \"4\" Provide the ruyaml configuration for indentation of mappings (dicts) and sequences (lists) and the indentation offset for elements. See the ruyaml configuration documentation: https://ruyaml.readthedocs.io/en/latest/detail.html#indentation-of-block-sequences Line Length (Width) \u00b6 Default: line_length: int = 80 Environment variable override: export YAMLFIX_LINE_LENGTH = \"80\" Configure the line-length / width configuration for ruyaml . With this configuration long multiline-strings will be wrapped at that point and flow-style lists will be converted to block-style if they are longer than the provided value. None Representation \u00b6 Default: none_representation: str = \"\" Environment variable override: export YAMLFIX_LINE_LENGTH = \"\" In yaml -files an absence of a value can be described in multiple canonical ways. This configuration enforces a user-defined representation for None values. For example: Valid None representation values are (empty string) , null , Null , NULL , ~ . Provided the source yaml file looks like this: none_value1 : none_value2 : null none_value3 : Null none_value4 : NULL none_value5 : ~ The default behaviour (empty string) representation would look like this: none_value1 : none_value2 : none_value3 : none_value4 : none_value5 : With this option set to none_representation=\"null\" it would look like this: none_value1 : null none_value2 : null none_value3 : null none_value4 : null none_value5 : null Quote Basic Values \u00b6 Default: quote_basic_values: bool = False Environment variable override: export YAMLFIX_quote_basic_values = \"false\" Per default ruyaml will quote only values where it is necessary to explicitly define the type of a value. This is the case for numbers and boolean values for example. If your yaml -file contains a value of type string that would look like a number, then this value needs to be quoted. This option allows for quoting of all simple values in mappings (dicts) and sequences (lists) to enable a homogeneous look and feel for string lists / simple key/value mappings. For example: # option set to false stringKey1 : abc stringKey2 : \"123\" stringList : [ abc , \"123\" ] # option set to true stringKey1 : \"abc\" stringKey2 : \"123\" stringList : [ \"abc\" , \"123\" ] Quote Keys and Basic Values \u00b6 Default: quote_keys_and_basic_values: bool = False Environment variable override: export YAMLFIX_quote_keys_and_basic_values = \"false\" Similar to the quote basic values configuration option, this option, in addition to the values themselves, quotes the keys as well. For example: # option set to false key : value list : [ item , item ] # option set to true \"key\" : \"value\" \"list\" : [ \"item\" , \"item\" ] Quote Representation \u00b6 Default: quote_representation: str = \"'\" Environment variable override: export YAMLFIX_quote_representation = \"'\" Configure which quotation string is used for quoting values. For example: # Option set to: ' key : 'value' # Option set to: \" key : \"value\" References \u00b6 As most open sourced programs, yamlfix is standing on the shoulders of giants, namely: yamlfmt : Inspiration and alternative of this program. I created a new one because the pace of their pull requests is really slow, they don't have tests, CI pipelines or documentation. ruyaml : A git based community maintained for of ruamel yaml parser. Click : Used to create the command line interface. maison : Used for finding, reading and parsing the configuration options. Pytest : Testing framework, enhanced by the awesome pytest-cases library that made the parametrization of the tests a lovely experience. Mypy : Python static type checker. Flakeheaven : Python linter with lots of checks . Black : Python formatter to keep a nice style without effort. Autoimport : Python formatter to automatically fix wrong import statements. isort : Python formatter to order the import statements. PDM : Command line tool to manage the dependencies. Mkdocs : To build this documentation site, with the Material theme . Safety : To check the installed dependencies for known security vulnerabilities. Bandit : To finds common security issues in Python code. Contributing \u00b6 For guidance on setting up a development environment, and how to make a contribution to yamlfix , see Contributing to yamlfix . Donations \u00b6 or If you are using some of my open-source tools, have enjoyed them, and want to say \"thanks\", this is a very strong way to do it. If your product/company depends on these tools, you can sponsor me to ensure I keep happily maintaining them. If these tools are helping you save money, time, effort, or frustrations; or they are helping you make money, be more productive, efficient, secure, enjoy a bit more your work, or get your product ready faster, this is a great way to show your appreciation. Thanks for that! And by sponsoring me, you are helping make these tools, that already help you, sustainable and healthy.","title":"yamlfix"},{"location":"#installing","text":"pip install yamlfix","title":"Installing"},{"location":"#usage","text":"Imagine we've got the following source code: book_library : - title : Why we sleep author : Matthew Walker - title : Harry Potter and the Methods of Rationality author : Eliezer Yudkowsky It has the following errors: There is no --- at the top. The indentation is all wrong. After running yamlfix the resulting source code will be: book_library : - title : Why we sleep author : Matthew Walker - title : Harry Potter and the Methods of Rationality author : Eliezer Yudkowsky yamlfix can be used both as command line tool and as a library. As a command line tool: $: yamlfix file.yaml As a library: from yamlfix import fix_files fix_files ([ \"file.py\" ]) If instead of reading from a file you want to fix the code saved into a variable, use fix_code : from yamlfix import fix_code source_code = \"a: 1\" fixed_code = fix_code ( source_code ) assert fixed_code == \"--- \\n a: 1 \\n \"","title":"Usage"},{"location":"#features","text":"yamlfix will do the following changes in your yaml source code per default: Add the header --- to your file. Correct truthy strings : 'True' -> true, 'no' -> 'false' Remove unnecessary apostrophes: title: 'Why we sleep' -> title: Why we sleep . Correct comments Ensure that there is exactly one newline at the end of each file, to comply with the POSIX standard . Split long lines. Respect Jinja2 syntax. Ensure a \\n exists at the end of the file. Convert short lists to flow-style list: [item, item] Convert lists longer than line-width to block-style: list : - item - item","title":"Features"},{"location":"#configuration","text":"yamlfix uses the maison library to find and parse configuration from standard locations, and can additionally be configured through environment variables. Any configuration found in the YamlfixConfig class can be set through your projects pyproject.toml , a custom toml -file or through the environment by providing an environment variable like {yamlfix_env_prefix}_{yamlfix_config_key} . Configuration options that are provided through environment variables have higher priority than options provided through configuration files and will override those keys. All provided configuration options , be it through pyproject.toml , config-files or env-vars, will be parsed by pydantic , so the target value type (str, bool, int, etc.) will be enforced, even if the provided value has the wrong type (for example all env vars in linux systems are strings, but pydantic will parse them to bools/numbers where necessary).","title":"Configuration"},{"location":"#auto-configure-through-pyprojecttoml","text":"The maison library will automatically pick up your yamlfix configuration through your projects pyproject.toml . It will look in the section named tool.yamlfix and apply the provided configuration options . For example: # pyproject.toml [tool.yamlfix] allow_duplicate_keys = true line_length = 80 none_representation = \"null\"","title":"Auto-Configure through pyproject.toml"},{"location":"#provide-config-files","text":"When running yamlfix as a standalone cli application it might be desireable to provide a config file containing just the configuration related to yamlfix . A cli-argument -c ( --config-file ) can be provided multiple times to read configuration values from toml formatted files. The rightmost value-files override the value-files preceding them, only trumped by environment variables. No section headers are necessary for these configuration files, as the expected behaviour is, that those files contain only configuration related to yamlfix . For example: # run yamlfix with two config files yamlfix -c base.toml --config-file environment.toml file.yaml # base.toml allow_duplicate_keys = false line_length = 100 # environment.toml allow_duplicate_keys = true These provided configuration files would result in a merged runtime-configuration of: # merged configuration allow_duplicate_keys = true line_length = 100","title":"Provide config-files"},{"location":"#configure-environment-prefix","text":"Per default yamlfix , when run through cli, will read any environment variable that starts with YAMLFIX_ and apply it to the merged runtime-configuration object. This default value can be overridden with the cli-parameter --env-prefix . For example: # set a configuration value with the default prefix export YAMLFIX_LINE_LENGTH = \"300\" # set a configuration value with the custom prefix export MY_PREFIX_NONE_REPRESENTATION = \"~\" # run yamlfix with a custom environment prefix yamlfix --env-prefix \"MY_PREFIX\" file.yaml These provided arguments and environment variables would result in a merged runtime-configuration of: # merged configuration # default value for line_length stays at: 80 none_representation = \"~\"","title":"Configure environment prefix"},{"location":"#configuration-options","text":"All fields configured in the YamlfixConfig class can be provided through the means mentioned in Configuration . Here are the currently available configuration options with short examples on their impact to provided yaml -files.","title":"Configuration Options"},{"location":"#allow-duplicate-keys","text":"Default: allow_duplicate_keys: bool = False Environment variable override: export YAMLFIX_ALLOW_DUPLICATE_KEYS = \"true\" This option toggles the ruyaml duplicate keys check . With this setting set to False , yamlfix will throw an error if the same key is defined more than once in a mapping / dictionary. To allow using the same key, set this value to True . You might want to enable this option, if you want to use multiple yaml-anchor merge keys, instead of providing them as sequence / list elements - see: https://github.com/pycontribs/ruyaml/issues/43","title":"Allow Duplicate Keys"},{"location":"#comments-min-spaces-from-content","text":"Default: comments_min_spaces_from_content: int = 2 Environment variable override: export YAMLFIX_COMMENTS_MIN_SPACES_FROM_CONTENT = \"2\" This option enforces minimum spacing between the content of a line and the start of an inline-comment. It is the enforcement implementation to the yamllint rule rules.comments.min-spaces-from-content - see: https://yamllint.readthedocs.io/en/stable/rules.html#module-yamllint.rules.comments","title":"Comments Min Spaces From Content"},{"location":"#comments-require-starting-space","text":"Default: comments_require_starting_space: bool = True Environment variable override: export YAMLFIX_COMMENTS_REQUIRE_STARTING_SPACE = \"true\" This option enforces a space between the comment indicator ( # ) and the first character in the comment. It implements the enforcement of the yamllint rule rules.comments.require-starting-space - see: https://yamllint.readthedocs.io/en/stable/rules.html#module-yamllint.rules.comments","title":"Comments Require Starting Space"},{"location":"#config-path","text":"Default: config_path: Optional[str] = None Environment variable override: export YAMLFIX_CONFIG_PATH = \"/etc/yamlfix/\" Configure the base config-path that maison will look for a pyproject.toml configuration file. This path is traversed upwards until such a file is found.","title":"Config Path"},{"location":"#explicit-document-start","text":"Default: explicit_start: bool = True Environment variable override: export YAMLFIX_EXPLICIT_START = \"true\" Add or remove the explicit document start ( --- ) for yaml -files. For example: Set to true : --- project_name : yamlfix Set to false : project_name : yamlfix","title":"Explicit Document Start"},{"location":"#sequence-list-style","text":"Default: sequence_style: YamlNodeStyle = YamlNodeStyle.FLOW_STYLE Environment variable override: export YAMLFIX_SEQUENCE_STYLE = \"flow_style\" Available values: flow_style , block_style , keep_style Transform sequences (lists) to either flow-style, block-style or leave them as-is. If enabled yamlfix will also ensure, that flow-style lists are automatically converted to block-style if the resulting key+list elements would breach the line-length. For example: Set to true (flow-style): --- list : [ item , item , item ] Set to false (block-style): --- list : - item - item - item","title":"Sequence (List) Style"},{"location":"#indentation","text":"Default: indent_mapping: int = 2 indent_offset: int = 2 indent_sequence: int = 4 Environment variable override: export YAMLFIX_INDENT_MAPPING = \"2\" export YAMLFIX_INDENT_OFFSET = \"2\" export YAMLFIX_INDENT_SEQUENCE = \"4\" Provide the ruyaml configuration for indentation of mappings (dicts) and sequences (lists) and the indentation offset for elements. See the ruyaml configuration documentation: https://ruyaml.readthedocs.io/en/latest/detail.html#indentation-of-block-sequences","title":"Indentation"},{"location":"#line-length-width","text":"Default: line_length: int = 80 Environment variable override: export YAMLFIX_LINE_LENGTH = \"80\" Configure the line-length / width configuration for ruyaml . With this configuration long multiline-strings will be wrapped at that point and flow-style lists will be converted to block-style if they are longer than the provided value.","title":"Line Length (Width)"},{"location":"#none-representation","text":"Default: none_representation: str = \"\" Environment variable override: export YAMLFIX_LINE_LENGTH = \"\" In yaml -files an absence of a value can be described in multiple canonical ways. This configuration enforces a user-defined representation for None values. For example: Valid None representation values are (empty string) , null , Null , NULL , ~ . Provided the source yaml file looks like this: none_value1 : none_value2 : null none_value3 : Null none_value4 : NULL none_value5 : ~ The default behaviour (empty string) representation would look like this: none_value1 : none_value2 : none_value3 : none_value4 : none_value5 : With this option set to none_representation=\"null\" it would look like this: none_value1 : null none_value2 : null none_value3 : null none_value4 : null none_value5 : null","title":"None Representation"},{"location":"#quote-basic-values","text":"Default: quote_basic_values: bool = False Environment variable override: export YAMLFIX_quote_basic_values = \"false\" Per default ruyaml will quote only values where it is necessary to explicitly define the type of a value. This is the case for numbers and boolean values for example. If your yaml -file contains a value of type string that would look like a number, then this value needs to be quoted. This option allows for quoting of all simple values in mappings (dicts) and sequences (lists) to enable a homogeneous look and feel for string lists / simple key/value mappings. For example: # option set to false stringKey1 : abc stringKey2 : \"123\" stringList : [ abc , \"123\" ] # option set to true stringKey1 : \"abc\" stringKey2 : \"123\" stringList : [ \"abc\" , \"123\" ]","title":"Quote Basic Values"},{"location":"#quote-keys-and-basic-values","text":"Default: quote_keys_and_basic_values: bool = False Environment variable override: export YAMLFIX_quote_keys_and_basic_values = \"false\" Similar to the quote basic values configuration option, this option, in addition to the values themselves, quotes the keys as well. For example: # option set to false key : value list : [ item , item ] # option set to true \"key\" : \"value\" \"list\" : [ \"item\" , \"item\" ]","title":"Quote Keys and Basic Values"},{"location":"#quote-representation","text":"Default: quote_representation: str = \"'\" Environment variable override: export YAMLFIX_quote_representation = \"'\" Configure which quotation string is used for quoting values. For example: # Option set to: ' key : 'value' # Option set to: \" key : \"value\"","title":"Quote Representation"},{"location":"#references","text":"As most open sourced programs, yamlfix is standing on the shoulders of giants, namely: yamlfmt : Inspiration and alternative of this program. I created a new one because the pace of their pull requests is really slow, they don't have tests, CI pipelines or documentation. ruyaml : A git based community maintained for of ruamel yaml parser. Click : Used to create the command line interface. maison : Used for finding, reading and parsing the configuration options. Pytest : Testing framework, enhanced by the awesome pytest-cases library that made the parametrization of the tests a lovely experience. Mypy : Python static type checker. Flakeheaven : Python linter with lots of checks . Black : Python formatter to keep a nice style without effort. Autoimport : Python formatter to automatically fix wrong import statements. isort : Python formatter to order the import statements. PDM : Command line tool to manage the dependencies. Mkdocs : To build this documentation site, with the Material theme . Safety : To check the installed dependencies for known security vulnerabilities. Bandit : To finds common security issues in Python code.","title":"References"},{"location":"#contributing","text":"For guidance on setting up a development environment, and how to make a contribution to yamlfix , see Contributing to yamlfix .","title":"Contributing"},{"location":"#donations","text":"or If you are using some of my open-source tools, have enjoyed them, and want to say \"thanks\", this is a very strong way to do it. If your product/company depends on these tools, you can sponsor me to ensure I keep happily maintaining them. If these tools are helping you save money, time, effort, or frustrations; or they are helping you make money, be more productive, efficient, secure, enjoy a bit more your work, or get your product ready faster, this is a great way to show your appreciation. Thanks for that! And by sponsoring me, you are helping make these tools, that already help you, sustainable and healthy.","title":"Donations"},{"location":"contributing/","text":"So you've started using yamlfix and want to show your gratitude to the project, depending on your programming skills there are different ways to do so. I don't know how to program \u00b6 There are several ways you can contribute: Open an issue if you encounter any bug or to let us know if you want a new feature to be implemented. Spread the word about the program. Review the documentation and try to improve it. I know how to program in Python \u00b6 If you have some python knowledge there are some additional ways to contribute. We've ordered the issues in milestones , check the issues in the smaller one, as it's where we'll be spending most of our efforts. Try the good first issues , as they are expected to be easier to get into the project. We develop the program with TDD , so we expect any contribution to have it's associated tests. We also try to maintain an updated documentation of the project, so think if your contribution needs to update it. We know that the expected code quality is above average. Therefore it might be changeling to get the initial grasp of the project structure, know how to make the tests, update the documentation or use all the project technology stack. but please don't let this fact discourage you from contributing: If you want to develop a new feature, explain how you'd like to do it in the related issue. If you don't know how to test your code, do the pull request without the tests and we'll try to do them for you. Issues \u00b6 Questions, feature requests and bug reports are all welcome as issues. To report a security vulnerability, please see our security policy instead. To make it as simple as possible for us to help you, please include the output of the following call in your issue: python -c \"import yamlfix.version; print(yamlfix.version.version_info())\" or if you have make installed, you can use make version . Please try to always include the above unless you're unable to install yamlfix or know it's not relevant to your question or feature request. Pull Requests \u00b6 yamlfix is released regularly so you should see your improvements release in a matter of days or weeks. Note Unless your change is trivial (typo, docs tweak etc.), please create an issue to discuss the change before creating a pull request. If you're looking for something to get your teeth into, check out the \"help wanted\" label on github. Development facilities \u00b6 To make contributing as easy and fast as possible, you'll want to run tests and linting locally. tl;dr : use make format to fix formatting, make to run tests and linting & make docs to build the docs. You'll need to have python 3.7 or 3.8, virtualenv, git, and make installed. Clone your fork and go into the repository directory: git clone git@github.com:<your username>/yamlfix.git cd yamlfix Set up the virtualenv for running tests: virtualenv -p ` which python3.7 ` env source env/bin/activate Install pdm our package manager with the next command or using any of the other recommended methods . curl -sSL https://raw.githubusercontent.com/pdm-project/pdm/main/install-pdm.py | python3 - Install yamlfix, dependencies and configure the pre-commits: make install Checkout a new branch and make your changes: git checkout -b my-new-feature-branch Fix formatting and imports: yamlfix uses black to enforce formatting and isort to fix imports. make format Run tests and linting: make There are more sub-commands in Makefile like test-code , test-examples , mypy or security which you might want to use, but generally make should be all you need. If you need to pass specific arguments to pytest use the ARGS variable, for example make test ARGS='-k test_markdownlint_passes' . Build documentation: If you have changed the documentation, make sure it builds the static site. Once built it will serve the documentation at localhost:8000 : make docs Commit, push, and create your pull request. Make a new release: To generate the changelog of the new changes, build the package, upload to pypi and clean the build files use make bump . We'd love you to contribute to yamlfix !","title":"Contributing"},{"location":"contributing/#i-dont-know-how-to-program","text":"There are several ways you can contribute: Open an issue if you encounter any bug or to let us know if you want a new feature to be implemented. Spread the word about the program. Review the documentation and try to improve it.","title":"I don't know how to program"},{"location":"contributing/#i-know-how-to-program-in-python","text":"If you have some python knowledge there are some additional ways to contribute. We've ordered the issues in milestones , check the issues in the smaller one, as it's where we'll be spending most of our efforts. Try the good first issues , as they are expected to be easier to get into the project. We develop the program with TDD , so we expect any contribution to have it's associated tests. We also try to maintain an updated documentation of the project, so think if your contribution needs to update it. We know that the expected code quality is above average. Therefore it might be changeling to get the initial grasp of the project structure, know how to make the tests, update the documentation or use all the project technology stack. but please don't let this fact discourage you from contributing: If you want to develop a new feature, explain how you'd like to do it in the related issue. If you don't know how to test your code, do the pull request without the tests and we'll try to do them for you.","title":"I know how to program in Python"},{"location":"contributing/#issues","text":"Questions, feature requests and bug reports are all welcome as issues. To report a security vulnerability, please see our security policy instead. To make it as simple as possible for us to help you, please include the output of the following call in your issue: python -c \"import yamlfix.version; print(yamlfix.version.version_info())\" or if you have make installed, you can use make version . Please try to always include the above unless you're unable to install yamlfix or know it's not relevant to your question or feature request.","title":"Issues"},{"location":"contributing/#pull-requests","text":"yamlfix is released regularly so you should see your improvements release in a matter of days or weeks. Note Unless your change is trivial (typo, docs tweak etc.), please create an issue to discuss the change before creating a pull request. If you're looking for something to get your teeth into, check out the \"help wanted\" label on github.","title":"Pull Requests"},{"location":"contributing/#development-facilities","text":"To make contributing as easy and fast as possible, you'll want to run tests and linting locally. tl;dr : use make format to fix formatting, make to run tests and linting & make docs to build the docs. You'll need to have python 3.7 or 3.8, virtualenv, git, and make installed. Clone your fork and go into the repository directory: git clone git@github.com:<your username>/yamlfix.git cd yamlfix Set up the virtualenv for running tests: virtualenv -p ` which python3.7 ` env source env/bin/activate Install pdm our package manager with the next command or using any of the other recommended methods . curl -sSL https://raw.githubusercontent.com/pdm-project/pdm/main/install-pdm.py | python3 - Install yamlfix, dependencies and configure the pre-commits: make install Checkout a new branch and make your changes: git checkout -b my-new-feature-branch Fix formatting and imports: yamlfix uses black to enforce formatting and isort to fix imports. make format Run tests and linting: make There are more sub-commands in Makefile like test-code , test-examples , mypy or security which you might want to use, but generally make should be all you need. If you need to pass specific arguments to pytest use the ARGS variable, for example make test ARGS='-k test_markdownlint_passes' . Build documentation: If you have changed the documentation, make sure it builds the static site. Once built it will serve the documentation at localhost:8000 : make docs Commit, push, and create your pull request. Make a new release: To generate the changelog of the new changes, build the package, upload to pypi and clean the build files use make bump . We'd love you to contribute to yamlfix !","title":"Development facilities"},{"location":"editor_integration/","text":"For a smoother experience, you can run yamlfix automatically each time each time you save your file in your editor or when you run git commit . Vim \u00b6 To integrate yamlfix into Vim, I recommend using the ale plugin . If you are new to ALE, check this post . ale is configured to run yamlfix automatically by default. pre-commit \u00b6 You can run yamlfix before we do a commit using the pre-commit framework. If you don't know how to use it, follow these guidelines . You'll need to add the following lines to your project's .pre-commit-config.yaml file. repos : - repo : https://github.com/lyz-code/yamlfix/ rev : master hooks : - id : yamlfix","title":"Editor Integration"},{"location":"editor_integration/#vim","text":"To integrate yamlfix into Vim, I recommend using the ale plugin . If you are new to ALE, check this post . ale is configured to run yamlfix automatically by default.","title":"Vim"},{"location":"editor_integration/#pre-commit","text":"You can run yamlfix before we do a commit using the pre-commit framework. If you don't know how to use it, follow these guidelines . You'll need to add the following lines to your project's .pre-commit-config.yaml file. repos : - repo : https://github.com/lyz-code/yamlfix/ rev : master hooks : - id : yamlfix","title":"pre-commit"},{"location":"reference/","text":"yamlfix.adapters \u00b6 Define adapter / helper classes to hide unrelated functionality in. SourceCodeFixer \u00b6 Adapter that holds all source code yaml fixers. Source code in yamlfix/adapters.py 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 class SourceCodeFixer : \"\"\"Adapter that holds all source code yaml fixers.\"\"\" def __init__ ( self , yaml : Yaml , config : Optional [ YamlfixConfig ]) -> None : \"\"\"Initialize the source code fixer adapter with a configured yaml fixer \\ instance and optional yamlfix config. Args: yaml: Initialized Ruamel formatter to use for source code correction. config: Small set of user provided configuration options for yamlfix. \"\"\" self . yaml = yaml . yaml self . config = config or YamlfixConfig () def fix ( self , source_code : str ) -> str : \"\"\"Run all yaml source code fixers. Args: source_code: Source code to be corrected. Returns: Corrected source code. \"\"\" log . debug ( \"Running source code fixers...\" ) fixers = [ self . _fix_truthy_strings , self . _fix_jinja_variables , self . _ruamel_yaml_fixer , self . _restore_truthy_strings , self . _restore_jinja_variables , self . _restore_double_exclamations , self . _fix_comments , self . _fix_top_level_lists , self . _fix_flow_style_lists , self . _add_newline_at_end_of_file , ] for fixer in fixers : source_code = fixer ( source_code ) return source_code def _ruamel_yaml_fixer ( self , source_code : str ) -> str : \"\"\"Run Ruamel's yaml fixer. Args: source_code: Source code to be corrected. Returns: Corrected source code. \"\"\" log . debug ( \"Running ruamel yaml fixer...\" ) source_dicts = self . yaml . load_all ( source_code ) # Return the output to a string string_stream = StringIO () for source_dict in source_dicts : self . yaml . dump ( source_dict , string_stream ) source_code = string_stream . getvalue () string_stream . close () return source_code . strip () @staticmethod def _fix_top_level_lists ( source_code : str ) -> str : \"\"\"Deindent the source with a top level list. Documents like the following: ```yaml --- # Comment - item 1 - item 2 ``` Are wrongly indented by the ruyaml parser: ```yaml --- # Comment - item 1 - item 2 ``` This function restores the indentation back to the original. Args: source_code: Source code to be corrected. Returns: Corrected source code. \"\"\" log . debug ( \"Fixing top level lists...\" ) source_lines = source_code . splitlines () fixed_source_lines : List [ str ] = [] is_top_level_list : Optional [ bool ] = None indent : str = \"\" for line in source_lines : # Skip the heading and first empty lines if re . match ( r \"^(---|#.*|)$\" , line ): fixed_source_lines . append ( line ) continue # Check if the first valid line is an indented list item if re . match ( r \"\\s*- +.*\" , line ) and is_top_level_list is None : is_top_level_list = True # Extract the indentation level serialized_line = re . match ( r \"(?P<indent>\\s*)- +(?P<content>.*)\" , line ) if serialized_line is None : # pragma: no cover raise ValueError ( f \"Error extracting the indentation of line: { line } \" ) indent = serialized_line . groupdict ()[ \"indent\" ] # Remove the indentation from the line fixed_source_lines . append ( re . sub ( rf \"^ { indent } (.*)\" , r \"\\1\" , line )) elif is_top_level_list : # ruyaml doesn't change the indentation of comments if re . match ( r \"\\s*#.*\" , line ): fixed_source_lines . append ( line ) else : fixed_source_lines . append ( re . sub ( rf \"^ { indent } (.*)\" , r \"\\1\" , line )) else : return source_code return \" \\n \" . join ( fixed_source_lines ) @staticmethod def _fix_flow_style_lists ( source_code : str ) -> str : \"\"\"Fix trailing newlines within flow-style lists. Documents like the following: ```yaml --- list: [\"a\", b, 'c'] next-element: \"d\" ``` Are wrongly formatted by the ruyaml parser: ```yaml --- list: [\"a\", b, 'c' ] next-element: \"d\" ``` This function moves the closing bracket to the end of the flow-style list definition. Args: source_code: Source code to be corrected. Returns: Corrected source code. \"\"\" log . debug ( \"Fixing flow-style lists...\" ) source_lines = source_code . splitlines () reversed_fixed_source_lines : List [ str ] = [] should_append_square_brackets : bool = False for line in reversed ( source_lines ): if line == \"]\" : should_append_square_brackets = True continue if line == \"\" : reversed_fixed_source_lines . append ( line ) continue if should_append_square_brackets : should_append_square_brackets = False reversed_fixed_source_lines . append ( line + \"]\" ) else : reversed_fixed_source_lines . append ( line ) return \" \\n \" . join ( reversed ( reversed_fixed_source_lines )) @staticmethod def _fix_truthy_strings ( source_code : str ) -> str : \"\"\"Convert common strings that refer to booleans. All caps variations of true, yes and on are transformed to true, while false, no and off are transformed to false. Ruyaml understands these strings and converts them to the lower version of the word instead of converting them to true and false. [More info](https://yamllint.readthedocs.io/en/stable/rules.html#module-yamllint.rules.truthy) # noqa: E501 Args: source_code: Source code to be corrected. Returns: Corrected source code. \"\"\" log . debug ( \"Fixing truthy strings...\" ) source_lines = source_code . splitlines () fixed_source_lines : List [ str ] = [] for line in source_lines : line_contains_true = re . match ( r \"(?P<pre_boolean_text>.*(:|-) )(true|yes|on)$\" , line , re . IGNORECASE ) line_contains_false = re . match ( r \"(?P<pre_boolean_text>.*(:|-) )(false|no|off)$\" , line , re . IGNORECASE ) if line_contains_true : fixed_source_lines . append ( f \" { line_contains_true . groupdict ()[ 'pre_boolean_text' ] } true\" ) elif line_contains_false : fixed_source_lines . append ( f \" { line_contains_false . groupdict ()[ 'pre_boolean_text' ] } false\" ) else : fixed_source_lines . append ( line ) return \" \\n \" . join ( fixed_source_lines ) @staticmethod def _restore_truthy_strings ( source_code : str ) -> str : \"\"\"Restore truthy strings to strings. The Ruyaml parser removes the apostrophes of all the caps variations of the strings 'yes', 'on', no and 'off' as it interprets them as booleans. As this function is run after _fix_truthy_strings, those strings are meant to be strings. So we're turning them back from booleans to strings. Args: source_code: Source code to be corrected. Returns: Corrected source code. \"\"\" log . debug ( \"Restoring truthy strings...\" ) source_lines = source_code . splitlines () fixed_source_lines : List [ str ] = [] for line in source_lines : line_contains_valid_truthy_string = re . match ( r \"(?P<pre_boolean_text>.*(:|-) )(?P<boolean_text>yes|on|no|off)$\" , line , re . IGNORECASE , ) if line_contains_valid_truthy_string : fixed_source_lines . append ( f \" { line_contains_valid_truthy_string . groupdict ()[ 'pre_boolean_text' ] } \" # noqa: E501 f \"' { line_contains_valid_truthy_string . groupdict ()[ 'boolean_text' ] } '\" ) else : fixed_source_lines . append ( line ) return \" \\n \" . join ( fixed_source_lines ) def _fix_comments ( self , source_code : str ) -> str : log . debug ( \"Fixing comments...\" ) config = self . config comment_start = \" \" * config . comments_min_spaces_from_content + \"#\" fixed_source_lines = [] for line in source_code . splitlines (): # Comment at the start of the line if config . comments_require_starting_space and re . search ( r \"(^|\\s)#\\w\" , line ): line = line . replace ( \"#\" , \"# \" ) # Comment in the middle of the line, but it's not part of a string if ( config . comments_min_spaces_from_content > 1 and \" #\" in line and line [ - 1 ] not in [ \"'\" , '\"' ] ): line = re . sub ( r \"(.+\\S)(\\s+?)#\" , rf \"\\1 { comment_start } \" , line ) fixed_source_lines . append ( line ) return \" \\n \" . join ( fixed_source_lines ) @staticmethod def _restore_double_exclamations ( source_code : str ) -> str : \"\"\"Restore the double exclamation marks. The Ruyaml parser transforms the !!python statement to !%21python which breaks some programs. \"\"\" log . debug ( \"Restoring double exclamations...\" ) fixed_source_lines = [] double_exclamation = re . compile ( r \"!%21\" ) for line in source_code . splitlines (): if double_exclamation . search ( line ): line = line . replace ( r \"!%21\" , \"!!\" ) fixed_source_lines . append ( line ) return \" \\n \" . join ( fixed_source_lines ) @staticmethod def _add_newline_at_end_of_file ( source_code : str ) -> str : return source_code + \" \\n \" @staticmethod def _fix_jinja_variables ( source_code : str ) -> str : \"\"\"Remove spaces between jinja variables. So that they are not split in many lines by ruyaml Args: source_code: Source code to be corrected. Returns: Corrected source code. \"\"\" log . debug ( \"Fixing jinja2 variables...\" ) source_lines = source_code . splitlines () fixed_source_lines : List [ str ] = [] for line in source_lines : line_contains_jinja2_variable = re . search ( r \"{{.*}}\" , line ) if line_contains_jinja2_variable : line = SourceCodeFixer . _encode_jinja2_line ( line ) fixed_source_lines . append ( line ) return \" \\n \" . join ( fixed_source_lines ) @staticmethod def _encode_jinja2_line ( line : str ) -> str : \"\"\"Encode jinja variables so that they are not split. Using a special character to join the elements inside the {{ }}, so that they are all taken as the same word, and ruyamel doesn't split them. \"\"\" new_line = [] variable_terms : List [ str ] = [] for word in line . split ( \" \" ): if re . search ( \"}}\" , word ): variable_terms . append ( word ) new_line . append ( \"\u2605\" . join ( variable_terms )) variable_terms = [] elif re . search ( \"{{\" , word ) or len ( variable_terms ) > 0 : variable_terms . append ( word ) else : new_line . append ( word ) return \" \" . join ( new_line ) @staticmethod def _restore_jinja_variables ( source_code : str ) -> str : \"\"\"Restore the jinja2 variables to their original state. Remove the encoding introduced by _fix_jinja_variables to prevent ruyaml to split the variables. \"\"\" log . debug ( \"Restoring jinja2 variables...\" ) fixed_source_lines = [] for line in source_code . splitlines (): line_contains_jinja2_variable = re . search ( r \"{{.*}}\" , line ) if line_contains_jinja2_variable : line = line . replace ( \"\u2605\" , \" \" ) fixed_source_lines . append ( line ) return \" \\n \" . join ( fixed_source_lines ) __init__ ( yaml , config ) \u00b6 Initialize the source code fixer adapter with a configured yaml fixer instance and optional yamlfix config. Parameters: Name Type Description Default yaml Yaml Initialized Ruamel formatter to use for source code correction. required config Optional [ YamlfixConfig ] Small set of user provided configuration options for yamlfix. required Source code in yamlfix/adapters.py 324 325 326 327 328 329 330 331 332 333 def __init__ ( self , yaml : Yaml , config : Optional [ YamlfixConfig ]) -> None : \"\"\"Initialize the source code fixer adapter with a configured yaml fixer \\ instance and optional yamlfix config. Args: yaml: Initialized Ruamel formatter to use for source code correction. config: Small set of user provided configuration options for yamlfix. \"\"\" self . yaml = yaml . yaml self . config = config or YamlfixConfig () fix ( source_code ) \u00b6 Run all yaml source code fixers. Parameters: Name Type Description Default source_code str Source code to be corrected. required Returns: Type Description str Corrected source code. Source code in yamlfix/adapters.py 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 def fix ( self , source_code : str ) -> str : \"\"\"Run all yaml source code fixers. Args: source_code: Source code to be corrected. Returns: Corrected source code. \"\"\" log . debug ( \"Running source code fixers...\" ) fixers = [ self . _fix_truthy_strings , self . _fix_jinja_variables , self . _ruamel_yaml_fixer , self . _restore_truthy_strings , self . _restore_jinja_variables , self . _restore_double_exclamations , self . _fix_comments , self . _fix_top_level_lists , self . _fix_flow_style_lists , self . _add_newline_at_end_of_file , ] for fixer in fixers : source_code = fixer ( source_code ) return source_code Yaml \u00b6 Adapter that holds the configured ruaml yaml fixer. Source code in yamlfix/adapters.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 class Yaml : \"\"\"Adapter that holds the configured ruaml yaml fixer.\"\"\" def __init__ ( self , config : Optional [ YamlfixConfig ]) -> None : \"\"\"Initialize the yaml adapter with an optional yamlfix config. Args: config: Small set of user provided configuration options for yamlfix. \"\"\" self . yaml = YAML () self . config = config or YamlfixConfig () # we have to call setattr with the string value, because the internal ruyaml # implementation does the same thing and does not expose the attribute itself setattr ( # noqa: B010 self . yaml , \"_representer\" , YamlfixRepresenter ( self . config , self . yaml . default_style , self . yaml . default_flow_style , self . yaml , ), ) self . _base_configuration () def _base_configuration ( self ) -> None : \"\"\"Configure base settings for Ruamel's yaml.\"\"\" log . debug ( \"Running ruamel yaml base configuration...\" ) config = self . config # Configure YAML formatter self . yaml . indent ( mapping = config . indent_mapping , sequence = config . indent_sequence , offset = config . indent_offset , ) self . yaml . allow_duplicate_keys = config . allow_duplicate_keys # Start the document with --- # ignore: variable has type None, what can we do, it doesn't have type hints... self . yaml . explicit_start = config . explicit_start # type: ignore self . yaml . width = config . line_length # type: ignore __init__ ( config ) \u00b6 Initialize the yaml adapter with an optional yamlfix config. Parameters: Name Type Description Default config Optional [ YamlfixConfig ] Small set of user provided configuration options for yamlfix. required Source code in yamlfix/adapters.py 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 def __init__ ( self , config : Optional [ YamlfixConfig ]) -> None : \"\"\"Initialize the yaml adapter with an optional yamlfix config. Args: config: Small set of user provided configuration options for yamlfix. \"\"\" self . yaml = YAML () self . config = config or YamlfixConfig () # we have to call setattr with the string value, because the internal ruyaml # implementation does the same thing and does not expose the attribute itself setattr ( # noqa: B010 self . yaml , \"_representer\" , YamlfixRepresenter ( self . config , self . yaml . default_style , self . yaml . default_flow_style , self . yaml , ), ) self . _base_configuration () YamlfixRepresenter \u00b6 Bases: RoundTripRepresenter Yamlfix's custom implementation of the ruyaml.RoundTripRepresenter that can be configured with YamlfixConfig. Source code in yamlfix/adapters.py 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 class YamlfixRepresenter ( RoundTripRepresenter ): \"\"\"Yamlfix's custom implementation of the ruyaml.RoundTripRepresenter\\ that can be configured with YamlfixConfig.\"\"\" def __init__ ( self , config : YamlfixConfig , default_style : Optional [ str ] = None , default_flow_style : Optional [ bool ] = None , dumper : Optional [ YAML ] = None , ) -> None : \"\"\"Initialize the YamlfixRepresenter and its parent RoundTripRepresenter.\"\"\" RoundTripRepresenter . __init__ ( self , default_style = default_style , default_flow_style = default_flow_style , dumper = dumper , ) self . config : YamlfixConfig = config self . patch_functions : List [ Callable [[ Node , Node ], None ]] = [] configure_patch_functions = [ self . _configure_quotation_for_basic_values , self . _configure_sequence_style , ] for patch_configurer in configure_patch_functions : patch_configurer () def represent_none ( self , data : Any ) -> ScalarNode : # noqa: ANN401 \"\"\"Configure how Ruamel's yaml represents None values. Default is an empty representation, could be overridden by canonical values like \"~\", \"null\", \"NULL\" \"\"\" if ( self . config . none_representation is None or self . config . none_representation == \"\" ): return super () . represent_none ( data ) return self . represent_scalar ( \"tag:yaml.org,2002:null\" , self . config . none_representation ) def represent_str ( self , data : Any ) -> ScalarNode : # noqa: ANN401 \"\"\"Configure Ruamel's yaml fixer to quote all yaml keys and simple* string values. Simple string values meaning: No multi line strings, as they are represented by LiteralScalarStrings instead. \"\"\" if ( not self . config . quote_keys_and_basic_values or self . config . quote_representation is None ): return super () . represent_str ( data ) return self . represent_scalar ( \"tag:yaml.org,2002:str\" , data , self . config . quote_representation ) def represent_mapping ( self , tag : Any , mapping : Any , flow_style : Optional [ Any ] = None # noqa: ANN401 ) -> MappingNode : \"\"\"Modify / Patch the original ruyaml representer represent_mapping value and\\ call the provided patch_function on its mapping_values.\"\"\" mapping_node : MappingNode = super () . represent_mapping ( tag , mapping , flow_style ) mapping_values : List [ Tuple [ ScalarNode , Node ]] = mapping_node . value if isinstance ( mapping_values , list ): for mapping_value in mapping_values : if isinstance ( mapping_value , tuple ): key_node : Node = mapping_value [ 0 ] value_node : Node = mapping_value [ 1 ] for patch_function in self . patch_functions : patch_function ( key_node , value_node ) return mapping_node def _configure_quotation_for_basic_values ( self ) -> None : \"\"\"Configure Ruamel's yaml fixer to quote only simple* yaml string values. Simple string values meaning: Any string that does not already have an explicit 'style' applied already -> multi line strings have a style value of \"|\" per default. \"\"\" config = self . config log . debug ( \"Setting up ruamel yaml 'quote simple values' configuration...\" ) def patch_quotations ( key_node : Node , value_node : Node ) -> None : # noqa: W0613 if not config . quote_basic_values or config . quote_representation is None : return # if this is a scalar value node itself, apply the quotations now self . _apply_simple_value_quotations ( value_node ) # if this is a sequence value node, check for value presence, complex # sequences and apply quotations to its values if not isinstance ( value_node , SequenceNode ) or value_node . value is None : return sequence_node : SequenceNode = value_node if self . _seq_contains_non_scalar_nodes ( sequence_node ) or self . _seq_contains_non_empty_comments ( sequence_node ): return for seq_value in sequence_node . value : self . _apply_simple_value_quotations ( seq_value ) self . patch_functions . append ( patch_quotations ) def _configure_sequence_style ( self ) -> None : \"\"\"Configure Ruamel's yaml fixer to represent lists as either block-style \\ or flow-style. Also make sure, that lists containing non-scalar values (other maps, \\ lists), lists that contain comments and lists that would breach the line-length are forced to block-style, regardless of configuration. Lists in block-style look like this: ``` list: # Comment for item - item - item - complex_item: # Comment for key key: value ``` Lists in flow-style look like this, we do not convert lists with complex values or lists with comments to that style, it is meant for simple lists, that contain only scalar values (string, int, bool, etc.) not other complex values (lists, dicts, comments, etc.) ``` list: [item, item, item] ``` Empty lists are not handled well in either style, so they are skipped as well, as you can only represent empty lists in flow-style either way. \"\"\" config = self . config log . debug ( \"Setting up ruamel yaml 'sequence flow style' configuration...\" ) def patch_sequence_style ( key_node : Node , value_node : Node ) -> None : if isinstance ( key_node , ScalarNode ) and isinstance ( value_node , SequenceNode ): # don't modify the sequence style at all, if the config value is # set to `keep_style` if config . sequence_style == YamlNodeStyle . KEEP_STYLE : return force_block_style : bool = False sequence_node : SequenceNode = value_node # check if the sequence node value is present and if it is not empty if not sequence_node . value : return # if this sequence contains non-scalar nodes (i.e. dicts, lists, etc.), # force block-style force_block_style = ( force_block_style or self . _seq_contains_non_scalar_nodes ( sequence_node ) ) # if this sequence contains non-empty comments, force block-style force_block_style = ( force_block_style or self . _seq_contains_non_empty_comments ( sequence_node ) ) # if this sequence, rendered in flow-style would breach the line-width, # force block-style roughly calculate the consumed width, in any case # ruyaml will fold flow-style lists if they breach the limit only # consider scalars, as non-scalar nodes should force block-style already force_block_style = ( force_block_style or self . _seq_length_longer_than_line_length ( key_node , sequence_node ) ) sequence_node . flow_style = ( config . sequence_style == YamlNodeStyle . FLOW_STYLE ) if force_block_style : sequence_node . flow_style = False self . patch_functions . append ( patch_sequence_style ) @staticmethod def _seq_contains_non_scalar_nodes ( seq_node : Node ) -> bool : return any ( not isinstance ( node , ScalarNode ) for node in seq_node . value ) @staticmethod def _seq_contains_non_empty_comments ( seq_node : Node ) -> bool : comment_tokens : List [ CommentToken ] = [] for node in seq_node . value : if isinstance ( node , ScalarNode ) and isinstance ( node . comment , list ): comment_tokens . extend ( node . comment ) return any ( isinstance ( comment_token , CommentToken ) and comment_token . value . strip () != \"\" for comment_token in comment_tokens ) def _seq_length_longer_than_line_length ( self , key_node : Node , seq_node : Node ) -> bool : config = self . config # This could be made configurable, or rather we could calculate if we need # the quotation spaces for the configured settings, but if we err on the # side of caution we can always force block-mode even for values that could # technically, without quotes, fit into the line-length # quotation marks around scalar value quote_length : int = 2 # comma and space between scalar values or colon and space # between key + values separator_length : int = 2 # opening and closing brackets that should fit on the same line bracket_length : int = 2 key_length : int = len ( str ( key_node . value )) + quote_length + separator_length scalar_length : int = 0 for node in seq_node . value : if isinstance ( node , ScalarNode ): scalar_length += len ( str ( node . value )) + quote_length + separator_length if key_length + scalar_length + bracket_length > config . line_length : return True return False def _apply_simple_value_quotations ( self , value_node : Node ) -> None : if ( isinstance ( value_node , ScalarNode ) and value_node . tag == \"tag:yaml.org,2002:str\" and value_node . style is None ): value_node . style = self . config . quote_representation __init__ ( config , default_style = None , default_flow_style = None , dumper = None ) \u00b6 Initialize the YamlfixRepresenter and its parent RoundTripRepresenter. Source code in yamlfix/adapters.py 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 def __init__ ( self , config : YamlfixConfig , default_style : Optional [ str ] = None , default_flow_style : Optional [ bool ] = None , dumper : Optional [ YAML ] = None , ) -> None : \"\"\"Initialize the YamlfixRepresenter and its parent RoundTripRepresenter.\"\"\" RoundTripRepresenter . __init__ ( self , default_style = default_style , default_flow_style = default_flow_style , dumper = dumper , ) self . config : YamlfixConfig = config self . patch_functions : List [ Callable [[ Node , Node ], None ]] = [] configure_patch_functions = [ self . _configure_quotation_for_basic_values , self . _configure_sequence_style , ] for patch_configurer in configure_patch_functions : patch_configurer () represent_mapping ( tag , mapping , flow_style = None ) \u00b6 Modify / Patch the original ruyaml representer represent_mapping value and call the provided patch_function on its mapping_values. Source code in yamlfix/adapters.py 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 def represent_mapping ( self , tag : Any , mapping : Any , flow_style : Optional [ Any ] = None # noqa: ANN401 ) -> MappingNode : \"\"\"Modify / Patch the original ruyaml representer represent_mapping value and\\ call the provided patch_function on its mapping_values.\"\"\" mapping_node : MappingNode = super () . represent_mapping ( tag , mapping , flow_style ) mapping_values : List [ Tuple [ ScalarNode , Node ]] = mapping_node . value if isinstance ( mapping_values , list ): for mapping_value in mapping_values : if isinstance ( mapping_value , tuple ): key_node : Node = mapping_value [ 0 ] value_node : Node = mapping_value [ 1 ] for patch_function in self . patch_functions : patch_function ( key_node , value_node ) return mapping_node represent_none ( data ) \u00b6 Configure how Ruamel's yaml represents None values. Default is an empty representation, could be overridden by canonical values like \"~\", \"null\", \"NULL\" Source code in yamlfix/adapters.py 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 def represent_none ( self , data : Any ) -> ScalarNode : # noqa: ANN401 \"\"\"Configure how Ruamel's yaml represents None values. Default is an empty representation, could be overridden by canonical values like \"~\", \"null\", \"NULL\" \"\"\" if ( self . config . none_representation is None or self . config . none_representation == \"\" ): return super () . represent_none ( data ) return self . represent_scalar ( \"tag:yaml.org,2002:null\" , self . config . none_representation ) represent_str ( data ) \u00b6 Configure Ruamel's yaml fixer to quote all yaml keys and simple* string values. Simple string values meaning: No multi line strings, as they are represented by LiteralScalarStrings instead. Source code in yamlfix/adapters.py 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 def represent_str ( self , data : Any ) -> ScalarNode : # noqa: ANN401 \"\"\"Configure Ruamel's yaml fixer to quote all yaml keys and simple* string values. Simple string values meaning: No multi line strings, as they are represented by LiteralScalarStrings instead. \"\"\" if ( not self . config . quote_keys_and_basic_values or self . config . quote_representation is None ): return super () . represent_str ( data ) return self . represent_scalar ( \"tag:yaml.org,2002:str\" , data , self . config . quote_representation ) yamlfix.config \u00b6 Define the configuration of the main program. configure_yamlfix ( yamlfix_config , config_files = None , additional_config = None ) \u00b6 Configure the YamlfixConfig object from .toml/.ini configuration files and additional config overrides. Source code in yamlfix/config.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 def configure_yamlfix ( yamlfix_config : YamlfixConfig , config_files : Optional [ List [ str ]] = None , additional_config : Optional [ Dict [ str , str ]] = None , ) -> None : \"\"\"Configure the YamlfixConfig object from .toml/.ini configuration files \\ and additional config overrides.\"\"\" config_path : Optional [ Path ] = None if additional_config : config_path_env : Optional [ str ] = additional_config . get ( \"config_path\" , None ) if config_path_env : config_path = Path ( config_path_env ) config : ProjectConfig = ProjectConfig ( config_schema = YamlfixConfig , merge_configs = True , project_name = \"yamlfix\" , source_files = config_files , starting_path = config_path , ) config_dict : Dict [ str , Any ] = config . to_dict () if additional_config : for override_key , override_val in additional_config . items (): config_dict [ override_key ] = override_val config . validate () config_dict = config . to_dict () for config_key , config_val in config_dict . items (): setattr ( yamlfix_config , config_key , config_val ) yamlfix.entrypoints \u00b6 Define the different ways to expose the program functionality. Functions ConsoleColorFormatter \u00b6 Bases: logging . Formatter Custom formatter that prints log levels to the console as colored plus signs. Source code in yamlfix/entrypoints/__init__.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class ConsoleColorFormatter ( logging . Formatter ): \"\"\"Custom formatter that prints log levels to the console as colored plus signs.\"\"\" colors = { logging . DEBUG : GREEN , logging . INFO : CYAN , logging . WARNING : YELLOW , logging . ERROR : RED , } def format ( self , record : logging . LogRecord ) -> str : \"\"\"Format log records as a colored plus sign followed by the log message.\"\"\" color = self . colors . get ( record . levelno , 0 ) self . _style . _fmt = f \"[ \\033 [ { color } m+ \\033 [0m] %(message)s\" # noqa: W0212 return super () . format ( record ) format ( record ) \u00b6 Format log records as a colored plus sign followed by the log message. Source code in yamlfix/entrypoints/__init__.py 27 28 29 30 31 def format ( self , record : logging . LogRecord ) -> str : \"\"\"Format log records as a colored plus sign followed by the log message.\"\"\" color = self . colors . get ( record . levelno , 0 ) self . _style . _fmt = f \"[ \\033 [ { color } m+ \\033 [0m] %(message)s\" # noqa: W0212 return super () . format ( record ) load_logger ( verbose = False ) \u00b6 Configure the Logging logger. Parameters: Name Type Description Default verbose bool Set the logging level to Debug. False Source code in yamlfix/entrypoints/__init__.py 34 35 36 37 38 39 40 41 42 43 def load_logger ( verbose : bool = False ) -> None : \"\"\"Configure the Logging logger. Args: verbose: Set the logging level to Debug. \"\"\" log_level = logging . DEBUG if verbose else logging . INFO logging . basicConfig ( stream = sys . stderr , level = log_level ) for handler in logging . getLogger () . handlers : handler . setFormatter ( ConsoleColorFormatter ()) yamlfix.model \u00b6 Define program entities like configuration value entities. YamlNodeStyle \u00b6 Bases: Enum Represent the desired YAML node style for sequences and mappings. Source code in yamlfix/model.py 8 9 10 11 12 13 class YamlNodeStyle ( Enum ): \"\"\"Represent the desired YAML node style for sequences and mappings.\"\"\" FLOW_STYLE = \"flow_style\" BLOCK_STYLE = \"block_style\" KEEP_STYLE = \"keep_style\" YamlfixConfig \u00b6 Bases: ConfigSchema Configuration entity for yamlfix. Source code in yamlfix/model.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class YamlfixConfig ( ConfigSchema ): \"\"\"Configuration entity for yamlfix.\"\"\" allow_duplicate_keys : bool = False comments_min_spaces_from_content : int = 2 comments_require_starting_space : bool = True config_path : Optional [ str ] = None explicit_start : bool = True indent_mapping : int = 2 indent_offset : int = 2 indent_sequence : int = 4 line_length : int = 80 none_representation : str = \"\" quote_basic_values : bool = False quote_keys_and_basic_values : bool = False quote_representation : str = \"'\" sequence_style : YamlNodeStyle = YamlNodeStyle . FLOW_STYLE yamlfix.services \u00b6 Define all the orchestration functionality required by the program to work. Classes and functions that connect the different domain model objects with the adapters and handlers to achieve the program's purpose. fix_code ( source_code , config = None ) \u00b6 Fix yaml source code to correct the format. It corrects these errors Add --- at the beginning of the file. Correct truthy strings: 'True' -> true, 'no' -> 'false' Remove unnecessary apostrophes: title: 'Why we sleep' -> title: Why we sleep . Parameters: Name Type Description Default source_code str Source code to be corrected. required config Optional [ YamlfixConfig ] Small set of user provided configuration options for yamlfix. None Returns: Type Description str Corrected source code. Source code in yamlfix/services.py 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 def fix_code ( source_code : str , config : Optional [ YamlfixConfig ] = None ) -> str : \"\"\"Fix yaml source code to correct the format. It corrects these errors: * Add --- at the beginning of the file. * Correct truthy strings: 'True' -> true, 'no' -> 'false' * Remove unnecessary apostrophes: `title: 'Why we sleep'` -> `title: Why we sleep`. Args: source_code: Source code to be corrected. config: Small set of user provided configuration options for yamlfix. Returns: Corrected source code. \"\"\" # Leave Ansible vaults unmodified if source_code . startswith ( \"$ANSIBLE_VAULT;\" ): return source_code if source_code . startswith ( \"#!\" ): # Skip the shebang line if present, leaving it unmodified eolpos = source_code . find ( \" \\n \" ) + 1 shebang = source_code [: eolpos ] source_code = source_code [ eolpos :] else : shebang = \"\" yaml = Yaml ( config = config ) fixer = SourceCodeFixer ( yaml = yaml , config = config ) source_code = fixer . fix ( source_code = source_code ) return shebang + source_code fix_files ( files , dry_run = None , config = None ) \u00b6 Fix the yaml source code of a list of files. If the input is taken from stdin, it will return the fixed value. Parameters: Name Type Description Default files Files List of files to fix. required dry_run Optional [ bool ] Whether to write changes or not. None config Optional [ YamlfixConfig ] Small set of user provided configuration options for yamlfix. None Returns: Type Description Union [ Optional [ str ], Tuple [ Optional [ str ], bool ]] A tuple with the following items: Union [ Optional [ str ], Tuple [ Optional [ str ], bool ]] Fixed code or None. Union [ Optional [ str ], Tuple [ Optional [ str ], bool ]] A bool to indicate whether at least one file has been changed. Source code in yamlfix/services.py 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 def fix_files ( # pylint: disable=too-many-branches files : Files , dry_run : Optional [ bool ] = None , config : Optional [ YamlfixConfig ] = None , ) -> Union [ Optional [ str ], Tuple [ Optional [ str ], bool ]]: # noqa: TAE002 \"\"\"Fix the yaml source code of a list of files. If the input is taken from stdin, it will return the fixed value. Args: files: List of files to fix. dry_run: Whether to write changes or not. config: Small set of user provided configuration options for yamlfix. Returns: A tuple with the following items: * Fixed code or None. * A bool to indicate whether at least one file has been changed. \"\"\" changed = False if dry_run is None : warnings . warn ( \"\"\" From 2023-01-12 fix_files will change the return type from `Optional[str]` to Tuple[Optional[str], bool], where the first element of the Tuple is the fixed source and the second a bool that returns whether the source has changed. For more information check https://github.com/lyz-code/yamlfix/pull/182 \"\"\" , UserWarning , ) for file_ in files : if isinstance ( file_ , str ): with open ( file_ , \"r\" , encoding = \"utf-8\" ) as file_descriptor : source = file_descriptor . read () file_name = file_ else : source = file_ . read () file_name = file_ . name log . debug ( \"Fixing file %s ...\" , file_name ) fixed_source = fix_code ( source , config ) if fixed_source != source : changed = True if file_name == \"<stdin>\" : if dry_run is None : return fixed_source return ( fixed_source , changed ) if fixed_source != source : if dry_run : log . debug ( \"Need to fix file %s .\" , file_name ) continue if isinstance ( file_ , str ): with open ( file_ , \"w\" , encoding = \"utf-8\" ) as file_descriptor : file_descriptor . write ( fixed_source ) else : file_ . seek ( 0 ) file_ . write ( fixed_source ) file_ . truncate () log . debug ( \"Fixed file %s .\" , file_name ) else : log . debug ( \"Left file %s unmodified.\" , file_name ) if dry_run is None : return None return ( None , changed ) yamlfix.version \u00b6 Utilities to retrieve the information of the program version. version_info () \u00b6 Display the version of the program, python and the platform. Source code in yamlfix/version.py 11 12 13 14 15 16 17 18 19 20 def version_info () -> str : \"\"\"Display the version of the program, python and the platform.\"\"\" return dedent ( f \"\"\" \\ ------------------------------------------------------------------ yamlfix: { __version__ } Python: { sys . version . split ( \" \" , maxsplit = 1 )[ 0 ] } Platform: { platform . platform () } ------------------------------------------------------------------\"\"\" )","title":"Reference"},{"location":"reference/#yamlfix.adapters","text":"Define adapter / helper classes to hide unrelated functionality in.","title":"adapters"},{"location":"reference/#yamlfix.adapters.SourceCodeFixer","text":"Adapter that holds all source code yaml fixers. Source code in yamlfix/adapters.py 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 class SourceCodeFixer : \"\"\"Adapter that holds all source code yaml fixers.\"\"\" def __init__ ( self , yaml : Yaml , config : Optional [ YamlfixConfig ]) -> None : \"\"\"Initialize the source code fixer adapter with a configured yaml fixer \\ instance and optional yamlfix config. Args: yaml: Initialized Ruamel formatter to use for source code correction. config: Small set of user provided configuration options for yamlfix. \"\"\" self . yaml = yaml . yaml self . config = config or YamlfixConfig () def fix ( self , source_code : str ) -> str : \"\"\"Run all yaml source code fixers. Args: source_code: Source code to be corrected. Returns: Corrected source code. \"\"\" log . debug ( \"Running source code fixers...\" ) fixers = [ self . _fix_truthy_strings , self . _fix_jinja_variables , self . _ruamel_yaml_fixer , self . _restore_truthy_strings , self . _restore_jinja_variables , self . _restore_double_exclamations , self . _fix_comments , self . _fix_top_level_lists , self . _fix_flow_style_lists , self . _add_newline_at_end_of_file , ] for fixer in fixers : source_code = fixer ( source_code ) return source_code def _ruamel_yaml_fixer ( self , source_code : str ) -> str : \"\"\"Run Ruamel's yaml fixer. Args: source_code: Source code to be corrected. Returns: Corrected source code. \"\"\" log . debug ( \"Running ruamel yaml fixer...\" ) source_dicts = self . yaml . load_all ( source_code ) # Return the output to a string string_stream = StringIO () for source_dict in source_dicts : self . yaml . dump ( source_dict , string_stream ) source_code = string_stream . getvalue () string_stream . close () return source_code . strip () @staticmethod def _fix_top_level_lists ( source_code : str ) -> str : \"\"\"Deindent the source with a top level list. Documents like the following: ```yaml --- # Comment - item 1 - item 2 ``` Are wrongly indented by the ruyaml parser: ```yaml --- # Comment - item 1 - item 2 ``` This function restores the indentation back to the original. Args: source_code: Source code to be corrected. Returns: Corrected source code. \"\"\" log . debug ( \"Fixing top level lists...\" ) source_lines = source_code . splitlines () fixed_source_lines : List [ str ] = [] is_top_level_list : Optional [ bool ] = None indent : str = \"\" for line in source_lines : # Skip the heading and first empty lines if re . match ( r \"^(---|#.*|)$\" , line ): fixed_source_lines . append ( line ) continue # Check if the first valid line is an indented list item if re . match ( r \"\\s*- +.*\" , line ) and is_top_level_list is None : is_top_level_list = True # Extract the indentation level serialized_line = re . match ( r \"(?P<indent>\\s*)- +(?P<content>.*)\" , line ) if serialized_line is None : # pragma: no cover raise ValueError ( f \"Error extracting the indentation of line: { line } \" ) indent = serialized_line . groupdict ()[ \"indent\" ] # Remove the indentation from the line fixed_source_lines . append ( re . sub ( rf \"^ { indent } (.*)\" , r \"\\1\" , line )) elif is_top_level_list : # ruyaml doesn't change the indentation of comments if re . match ( r \"\\s*#.*\" , line ): fixed_source_lines . append ( line ) else : fixed_source_lines . append ( re . sub ( rf \"^ { indent } (.*)\" , r \"\\1\" , line )) else : return source_code return \" \\n \" . join ( fixed_source_lines ) @staticmethod def _fix_flow_style_lists ( source_code : str ) -> str : \"\"\"Fix trailing newlines within flow-style lists. Documents like the following: ```yaml --- list: [\"a\", b, 'c'] next-element: \"d\" ``` Are wrongly formatted by the ruyaml parser: ```yaml --- list: [\"a\", b, 'c' ] next-element: \"d\" ``` This function moves the closing bracket to the end of the flow-style list definition. Args: source_code: Source code to be corrected. Returns: Corrected source code. \"\"\" log . debug ( \"Fixing flow-style lists...\" ) source_lines = source_code . splitlines () reversed_fixed_source_lines : List [ str ] = [] should_append_square_brackets : bool = False for line in reversed ( source_lines ): if line == \"]\" : should_append_square_brackets = True continue if line == \"\" : reversed_fixed_source_lines . append ( line ) continue if should_append_square_brackets : should_append_square_brackets = False reversed_fixed_source_lines . append ( line + \"]\" ) else : reversed_fixed_source_lines . append ( line ) return \" \\n \" . join ( reversed ( reversed_fixed_source_lines )) @staticmethod def _fix_truthy_strings ( source_code : str ) -> str : \"\"\"Convert common strings that refer to booleans. All caps variations of true, yes and on are transformed to true, while false, no and off are transformed to false. Ruyaml understands these strings and converts them to the lower version of the word instead of converting them to true and false. [More info](https://yamllint.readthedocs.io/en/stable/rules.html#module-yamllint.rules.truthy) # noqa: E501 Args: source_code: Source code to be corrected. Returns: Corrected source code. \"\"\" log . debug ( \"Fixing truthy strings...\" ) source_lines = source_code . splitlines () fixed_source_lines : List [ str ] = [] for line in source_lines : line_contains_true = re . match ( r \"(?P<pre_boolean_text>.*(:|-) )(true|yes|on)$\" , line , re . IGNORECASE ) line_contains_false = re . match ( r \"(?P<pre_boolean_text>.*(:|-) )(false|no|off)$\" , line , re . IGNORECASE ) if line_contains_true : fixed_source_lines . append ( f \" { line_contains_true . groupdict ()[ 'pre_boolean_text' ] } true\" ) elif line_contains_false : fixed_source_lines . append ( f \" { line_contains_false . groupdict ()[ 'pre_boolean_text' ] } false\" ) else : fixed_source_lines . append ( line ) return \" \\n \" . join ( fixed_source_lines ) @staticmethod def _restore_truthy_strings ( source_code : str ) -> str : \"\"\"Restore truthy strings to strings. The Ruyaml parser removes the apostrophes of all the caps variations of the strings 'yes', 'on', no and 'off' as it interprets them as booleans. As this function is run after _fix_truthy_strings, those strings are meant to be strings. So we're turning them back from booleans to strings. Args: source_code: Source code to be corrected. Returns: Corrected source code. \"\"\" log . debug ( \"Restoring truthy strings...\" ) source_lines = source_code . splitlines () fixed_source_lines : List [ str ] = [] for line in source_lines : line_contains_valid_truthy_string = re . match ( r \"(?P<pre_boolean_text>.*(:|-) )(?P<boolean_text>yes|on|no|off)$\" , line , re . IGNORECASE , ) if line_contains_valid_truthy_string : fixed_source_lines . append ( f \" { line_contains_valid_truthy_string . groupdict ()[ 'pre_boolean_text' ] } \" # noqa: E501 f \"' { line_contains_valid_truthy_string . groupdict ()[ 'boolean_text' ] } '\" ) else : fixed_source_lines . append ( line ) return \" \\n \" . join ( fixed_source_lines ) def _fix_comments ( self , source_code : str ) -> str : log . debug ( \"Fixing comments...\" ) config = self . config comment_start = \" \" * config . comments_min_spaces_from_content + \"#\" fixed_source_lines = [] for line in source_code . splitlines (): # Comment at the start of the line if config . comments_require_starting_space and re . search ( r \"(^|\\s)#\\w\" , line ): line = line . replace ( \"#\" , \"# \" ) # Comment in the middle of the line, but it's not part of a string if ( config . comments_min_spaces_from_content > 1 and \" #\" in line and line [ - 1 ] not in [ \"'\" , '\"' ] ): line = re . sub ( r \"(.+\\S)(\\s+?)#\" , rf \"\\1 { comment_start } \" , line ) fixed_source_lines . append ( line ) return \" \\n \" . join ( fixed_source_lines ) @staticmethod def _restore_double_exclamations ( source_code : str ) -> str : \"\"\"Restore the double exclamation marks. The Ruyaml parser transforms the !!python statement to !%21python which breaks some programs. \"\"\" log . debug ( \"Restoring double exclamations...\" ) fixed_source_lines = [] double_exclamation = re . compile ( r \"!%21\" ) for line in source_code . splitlines (): if double_exclamation . search ( line ): line = line . replace ( r \"!%21\" , \"!!\" ) fixed_source_lines . append ( line ) return \" \\n \" . join ( fixed_source_lines ) @staticmethod def _add_newline_at_end_of_file ( source_code : str ) -> str : return source_code + \" \\n \" @staticmethod def _fix_jinja_variables ( source_code : str ) -> str : \"\"\"Remove spaces between jinja variables. So that they are not split in many lines by ruyaml Args: source_code: Source code to be corrected. Returns: Corrected source code. \"\"\" log . debug ( \"Fixing jinja2 variables...\" ) source_lines = source_code . splitlines () fixed_source_lines : List [ str ] = [] for line in source_lines : line_contains_jinja2_variable = re . search ( r \"{{.*}}\" , line ) if line_contains_jinja2_variable : line = SourceCodeFixer . _encode_jinja2_line ( line ) fixed_source_lines . append ( line ) return \" \\n \" . join ( fixed_source_lines ) @staticmethod def _encode_jinja2_line ( line : str ) -> str : \"\"\"Encode jinja variables so that they are not split. Using a special character to join the elements inside the {{ }}, so that they are all taken as the same word, and ruyamel doesn't split them. \"\"\" new_line = [] variable_terms : List [ str ] = [] for word in line . split ( \" \" ): if re . search ( \"}}\" , word ): variable_terms . append ( word ) new_line . append ( \"\u2605\" . join ( variable_terms )) variable_terms = [] elif re . search ( \"{{\" , word ) or len ( variable_terms ) > 0 : variable_terms . append ( word ) else : new_line . append ( word ) return \" \" . join ( new_line ) @staticmethod def _restore_jinja_variables ( source_code : str ) -> str : \"\"\"Restore the jinja2 variables to their original state. Remove the encoding introduced by _fix_jinja_variables to prevent ruyaml to split the variables. \"\"\" log . debug ( \"Restoring jinja2 variables...\" ) fixed_source_lines = [] for line in source_code . splitlines (): line_contains_jinja2_variable = re . search ( r \"{{.*}}\" , line ) if line_contains_jinja2_variable : line = line . replace ( \"\u2605\" , \" \" ) fixed_source_lines . append ( line ) return \" \\n \" . join ( fixed_source_lines )","title":"SourceCodeFixer"},{"location":"reference/#yamlfix.adapters.SourceCodeFixer.__init__","text":"Initialize the source code fixer adapter with a configured yaml fixer instance and optional yamlfix config. Parameters: Name Type Description Default yaml Yaml Initialized Ruamel formatter to use for source code correction. required config Optional [ YamlfixConfig ] Small set of user provided configuration options for yamlfix. required Source code in yamlfix/adapters.py 324 325 326 327 328 329 330 331 332 333 def __init__ ( self , yaml : Yaml , config : Optional [ YamlfixConfig ]) -> None : \"\"\"Initialize the source code fixer adapter with a configured yaml fixer \\ instance and optional yamlfix config. Args: yaml: Initialized Ruamel formatter to use for source code correction. config: Small set of user provided configuration options for yamlfix. \"\"\" self . yaml = yaml . yaml self . config = config or YamlfixConfig ()","title":"__init__()"},{"location":"reference/#yamlfix.adapters.SourceCodeFixer.fix","text":"Run all yaml source code fixers. Parameters: Name Type Description Default source_code str Source code to be corrected. required Returns: Type Description str Corrected source code. Source code in yamlfix/adapters.py 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 def fix ( self , source_code : str ) -> str : \"\"\"Run all yaml source code fixers. Args: source_code: Source code to be corrected. Returns: Corrected source code. \"\"\" log . debug ( \"Running source code fixers...\" ) fixers = [ self . _fix_truthy_strings , self . _fix_jinja_variables , self . _ruamel_yaml_fixer , self . _restore_truthy_strings , self . _restore_jinja_variables , self . _restore_double_exclamations , self . _fix_comments , self . _fix_top_level_lists , self . _fix_flow_style_lists , self . _add_newline_at_end_of_file , ] for fixer in fixers : source_code = fixer ( source_code ) return source_code","title":"fix()"},{"location":"reference/#yamlfix.adapters.Yaml","text":"Adapter that holds the configured ruaml yaml fixer. Source code in yamlfix/adapters.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 class Yaml : \"\"\"Adapter that holds the configured ruaml yaml fixer.\"\"\" def __init__ ( self , config : Optional [ YamlfixConfig ]) -> None : \"\"\"Initialize the yaml adapter with an optional yamlfix config. Args: config: Small set of user provided configuration options for yamlfix. \"\"\" self . yaml = YAML () self . config = config or YamlfixConfig () # we have to call setattr with the string value, because the internal ruyaml # implementation does the same thing and does not expose the attribute itself setattr ( # noqa: B010 self . yaml , \"_representer\" , YamlfixRepresenter ( self . config , self . yaml . default_style , self . yaml . default_flow_style , self . yaml , ), ) self . _base_configuration () def _base_configuration ( self ) -> None : \"\"\"Configure base settings for Ruamel's yaml.\"\"\" log . debug ( \"Running ruamel yaml base configuration...\" ) config = self . config # Configure YAML formatter self . yaml . indent ( mapping = config . indent_mapping , sequence = config . indent_sequence , offset = config . indent_offset , ) self . yaml . allow_duplicate_keys = config . allow_duplicate_keys # Start the document with --- # ignore: variable has type None, what can we do, it doesn't have type hints... self . yaml . explicit_start = config . explicit_start # type: ignore self . yaml . width = config . line_length # type: ignore","title":"Yaml"},{"location":"reference/#yamlfix.adapters.Yaml.__init__","text":"Initialize the yaml adapter with an optional yamlfix config. Parameters: Name Type Description Default config Optional [ YamlfixConfig ] Small set of user provided configuration options for yamlfix. required Source code in yamlfix/adapters.py 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 def __init__ ( self , config : Optional [ YamlfixConfig ]) -> None : \"\"\"Initialize the yaml adapter with an optional yamlfix config. Args: config: Small set of user provided configuration options for yamlfix. \"\"\" self . yaml = YAML () self . config = config or YamlfixConfig () # we have to call setattr with the string value, because the internal ruyaml # implementation does the same thing and does not expose the attribute itself setattr ( # noqa: B010 self . yaml , \"_representer\" , YamlfixRepresenter ( self . config , self . yaml . default_style , self . yaml . default_flow_style , self . yaml , ), ) self . _base_configuration ()","title":"__init__()"},{"location":"reference/#yamlfix.adapters.YamlfixRepresenter","text":"Bases: RoundTripRepresenter Yamlfix's custom implementation of the ruyaml.RoundTripRepresenter that can be configured with YamlfixConfig. Source code in yamlfix/adapters.py 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 class YamlfixRepresenter ( RoundTripRepresenter ): \"\"\"Yamlfix's custom implementation of the ruyaml.RoundTripRepresenter\\ that can be configured with YamlfixConfig.\"\"\" def __init__ ( self , config : YamlfixConfig , default_style : Optional [ str ] = None , default_flow_style : Optional [ bool ] = None , dumper : Optional [ YAML ] = None , ) -> None : \"\"\"Initialize the YamlfixRepresenter and its parent RoundTripRepresenter.\"\"\" RoundTripRepresenter . __init__ ( self , default_style = default_style , default_flow_style = default_flow_style , dumper = dumper , ) self . config : YamlfixConfig = config self . patch_functions : List [ Callable [[ Node , Node ], None ]] = [] configure_patch_functions = [ self . _configure_quotation_for_basic_values , self . _configure_sequence_style , ] for patch_configurer in configure_patch_functions : patch_configurer () def represent_none ( self , data : Any ) -> ScalarNode : # noqa: ANN401 \"\"\"Configure how Ruamel's yaml represents None values. Default is an empty representation, could be overridden by canonical values like \"~\", \"null\", \"NULL\" \"\"\" if ( self . config . none_representation is None or self . config . none_representation == \"\" ): return super () . represent_none ( data ) return self . represent_scalar ( \"tag:yaml.org,2002:null\" , self . config . none_representation ) def represent_str ( self , data : Any ) -> ScalarNode : # noqa: ANN401 \"\"\"Configure Ruamel's yaml fixer to quote all yaml keys and simple* string values. Simple string values meaning: No multi line strings, as they are represented by LiteralScalarStrings instead. \"\"\" if ( not self . config . quote_keys_and_basic_values or self . config . quote_representation is None ): return super () . represent_str ( data ) return self . represent_scalar ( \"tag:yaml.org,2002:str\" , data , self . config . quote_representation ) def represent_mapping ( self , tag : Any , mapping : Any , flow_style : Optional [ Any ] = None # noqa: ANN401 ) -> MappingNode : \"\"\"Modify / Patch the original ruyaml representer represent_mapping value and\\ call the provided patch_function on its mapping_values.\"\"\" mapping_node : MappingNode = super () . represent_mapping ( tag , mapping , flow_style ) mapping_values : List [ Tuple [ ScalarNode , Node ]] = mapping_node . value if isinstance ( mapping_values , list ): for mapping_value in mapping_values : if isinstance ( mapping_value , tuple ): key_node : Node = mapping_value [ 0 ] value_node : Node = mapping_value [ 1 ] for patch_function in self . patch_functions : patch_function ( key_node , value_node ) return mapping_node def _configure_quotation_for_basic_values ( self ) -> None : \"\"\"Configure Ruamel's yaml fixer to quote only simple* yaml string values. Simple string values meaning: Any string that does not already have an explicit 'style' applied already -> multi line strings have a style value of \"|\" per default. \"\"\" config = self . config log . debug ( \"Setting up ruamel yaml 'quote simple values' configuration...\" ) def patch_quotations ( key_node : Node , value_node : Node ) -> None : # noqa: W0613 if not config . quote_basic_values or config . quote_representation is None : return # if this is a scalar value node itself, apply the quotations now self . _apply_simple_value_quotations ( value_node ) # if this is a sequence value node, check for value presence, complex # sequences and apply quotations to its values if not isinstance ( value_node , SequenceNode ) or value_node . value is None : return sequence_node : SequenceNode = value_node if self . _seq_contains_non_scalar_nodes ( sequence_node ) or self . _seq_contains_non_empty_comments ( sequence_node ): return for seq_value in sequence_node . value : self . _apply_simple_value_quotations ( seq_value ) self . patch_functions . append ( patch_quotations ) def _configure_sequence_style ( self ) -> None : \"\"\"Configure Ruamel's yaml fixer to represent lists as either block-style \\ or flow-style. Also make sure, that lists containing non-scalar values (other maps, \\ lists), lists that contain comments and lists that would breach the line-length are forced to block-style, regardless of configuration. Lists in block-style look like this: ``` list: # Comment for item - item - item - complex_item: # Comment for key key: value ``` Lists in flow-style look like this, we do not convert lists with complex values or lists with comments to that style, it is meant for simple lists, that contain only scalar values (string, int, bool, etc.) not other complex values (lists, dicts, comments, etc.) ``` list: [item, item, item] ``` Empty lists are not handled well in either style, so they are skipped as well, as you can only represent empty lists in flow-style either way. \"\"\" config = self . config log . debug ( \"Setting up ruamel yaml 'sequence flow style' configuration...\" ) def patch_sequence_style ( key_node : Node , value_node : Node ) -> None : if isinstance ( key_node , ScalarNode ) and isinstance ( value_node , SequenceNode ): # don't modify the sequence style at all, if the config value is # set to `keep_style` if config . sequence_style == YamlNodeStyle . KEEP_STYLE : return force_block_style : bool = False sequence_node : SequenceNode = value_node # check if the sequence node value is present and if it is not empty if not sequence_node . value : return # if this sequence contains non-scalar nodes (i.e. dicts, lists, etc.), # force block-style force_block_style = ( force_block_style or self . _seq_contains_non_scalar_nodes ( sequence_node ) ) # if this sequence contains non-empty comments, force block-style force_block_style = ( force_block_style or self . _seq_contains_non_empty_comments ( sequence_node ) ) # if this sequence, rendered in flow-style would breach the line-width, # force block-style roughly calculate the consumed width, in any case # ruyaml will fold flow-style lists if they breach the limit only # consider scalars, as non-scalar nodes should force block-style already force_block_style = ( force_block_style or self . _seq_length_longer_than_line_length ( key_node , sequence_node ) ) sequence_node . flow_style = ( config . sequence_style == YamlNodeStyle . FLOW_STYLE ) if force_block_style : sequence_node . flow_style = False self . patch_functions . append ( patch_sequence_style ) @staticmethod def _seq_contains_non_scalar_nodes ( seq_node : Node ) -> bool : return any ( not isinstance ( node , ScalarNode ) for node in seq_node . value ) @staticmethod def _seq_contains_non_empty_comments ( seq_node : Node ) -> bool : comment_tokens : List [ CommentToken ] = [] for node in seq_node . value : if isinstance ( node , ScalarNode ) and isinstance ( node . comment , list ): comment_tokens . extend ( node . comment ) return any ( isinstance ( comment_token , CommentToken ) and comment_token . value . strip () != \"\" for comment_token in comment_tokens ) def _seq_length_longer_than_line_length ( self , key_node : Node , seq_node : Node ) -> bool : config = self . config # This could be made configurable, or rather we could calculate if we need # the quotation spaces for the configured settings, but if we err on the # side of caution we can always force block-mode even for values that could # technically, without quotes, fit into the line-length # quotation marks around scalar value quote_length : int = 2 # comma and space between scalar values or colon and space # between key + values separator_length : int = 2 # opening and closing brackets that should fit on the same line bracket_length : int = 2 key_length : int = len ( str ( key_node . value )) + quote_length + separator_length scalar_length : int = 0 for node in seq_node . value : if isinstance ( node , ScalarNode ): scalar_length += len ( str ( node . value )) + quote_length + separator_length if key_length + scalar_length + bracket_length > config . line_length : return True return False def _apply_simple_value_quotations ( self , value_node : Node ) -> None : if ( isinstance ( value_node , ScalarNode ) and value_node . tag == \"tag:yaml.org,2002:str\" and value_node . style is None ): value_node . style = self . config . quote_representation","title":"YamlfixRepresenter"},{"location":"reference/#yamlfix.adapters.YamlfixRepresenter.__init__","text":"Initialize the YamlfixRepresenter and its parent RoundTripRepresenter. Source code in yamlfix/adapters.py 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 def __init__ ( self , config : YamlfixConfig , default_style : Optional [ str ] = None , default_flow_style : Optional [ bool ] = None , dumper : Optional [ YAML ] = None , ) -> None : \"\"\"Initialize the YamlfixRepresenter and its parent RoundTripRepresenter.\"\"\" RoundTripRepresenter . __init__ ( self , default_style = default_style , default_flow_style = default_flow_style , dumper = dumper , ) self . config : YamlfixConfig = config self . patch_functions : List [ Callable [[ Node , Node ], None ]] = [] configure_patch_functions = [ self . _configure_quotation_for_basic_values , self . _configure_sequence_style , ] for patch_configurer in configure_patch_functions : patch_configurer ()","title":"__init__()"},{"location":"reference/#yamlfix.adapters.YamlfixRepresenter.represent_mapping","text":"Modify / Patch the original ruyaml representer represent_mapping value and call the provided patch_function on its mapping_values. Source code in yamlfix/adapters.py 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 def represent_mapping ( self , tag : Any , mapping : Any , flow_style : Optional [ Any ] = None # noqa: ANN401 ) -> MappingNode : \"\"\"Modify / Patch the original ruyaml representer represent_mapping value and\\ call the provided patch_function on its mapping_values.\"\"\" mapping_node : MappingNode = super () . represent_mapping ( tag , mapping , flow_style ) mapping_values : List [ Tuple [ ScalarNode , Node ]] = mapping_node . value if isinstance ( mapping_values , list ): for mapping_value in mapping_values : if isinstance ( mapping_value , tuple ): key_node : Node = mapping_value [ 0 ] value_node : Node = mapping_value [ 1 ] for patch_function in self . patch_functions : patch_function ( key_node , value_node ) return mapping_node","title":"represent_mapping()"},{"location":"reference/#yamlfix.adapters.YamlfixRepresenter.represent_none","text":"Configure how Ruamel's yaml represents None values. Default is an empty representation, could be overridden by canonical values like \"~\", \"null\", \"NULL\" Source code in yamlfix/adapters.py 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 def represent_none ( self , data : Any ) -> ScalarNode : # noqa: ANN401 \"\"\"Configure how Ruamel's yaml represents None values. Default is an empty representation, could be overridden by canonical values like \"~\", \"null\", \"NULL\" \"\"\" if ( self . config . none_representation is None or self . config . none_representation == \"\" ): return super () . represent_none ( data ) return self . represent_scalar ( \"tag:yaml.org,2002:null\" , self . config . none_representation )","title":"represent_none()"},{"location":"reference/#yamlfix.adapters.YamlfixRepresenter.represent_str","text":"Configure Ruamel's yaml fixer to quote all yaml keys and simple* string values. Simple string values meaning: No multi line strings, as they are represented by LiteralScalarStrings instead. Source code in yamlfix/adapters.py 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 def represent_str ( self , data : Any ) -> ScalarNode : # noqa: ANN401 \"\"\"Configure Ruamel's yaml fixer to quote all yaml keys and simple* string values. Simple string values meaning: No multi line strings, as they are represented by LiteralScalarStrings instead. \"\"\" if ( not self . config . quote_keys_and_basic_values or self . config . quote_representation is None ): return super () . represent_str ( data ) return self . represent_scalar ( \"tag:yaml.org,2002:str\" , data , self . config . quote_representation )","title":"represent_str()"},{"location":"reference/#yamlfix.config","text":"Define the configuration of the main program.","title":"config"},{"location":"reference/#yamlfix.config.configure_yamlfix","text":"Configure the YamlfixConfig object from .toml/.ini configuration files and additional config overrides. Source code in yamlfix/config.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 def configure_yamlfix ( yamlfix_config : YamlfixConfig , config_files : Optional [ List [ str ]] = None , additional_config : Optional [ Dict [ str , str ]] = None , ) -> None : \"\"\"Configure the YamlfixConfig object from .toml/.ini configuration files \\ and additional config overrides.\"\"\" config_path : Optional [ Path ] = None if additional_config : config_path_env : Optional [ str ] = additional_config . get ( \"config_path\" , None ) if config_path_env : config_path = Path ( config_path_env ) config : ProjectConfig = ProjectConfig ( config_schema = YamlfixConfig , merge_configs = True , project_name = \"yamlfix\" , source_files = config_files , starting_path = config_path , ) config_dict : Dict [ str , Any ] = config . to_dict () if additional_config : for override_key , override_val in additional_config . items (): config_dict [ override_key ] = override_val config . validate () config_dict = config . to_dict () for config_key , config_val in config_dict . items (): setattr ( yamlfix_config , config_key , config_val )","title":"configure_yamlfix()"},{"location":"reference/#yamlfix.entrypoints","text":"Define the different ways to expose the program functionality. Functions","title":"entrypoints"},{"location":"reference/#yamlfix.entrypoints.ConsoleColorFormatter","text":"Bases: logging . Formatter Custom formatter that prints log levels to the console as colored plus signs. Source code in yamlfix/entrypoints/__init__.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class ConsoleColorFormatter ( logging . Formatter ): \"\"\"Custom formatter that prints log levels to the console as colored plus signs.\"\"\" colors = { logging . DEBUG : GREEN , logging . INFO : CYAN , logging . WARNING : YELLOW , logging . ERROR : RED , } def format ( self , record : logging . LogRecord ) -> str : \"\"\"Format log records as a colored plus sign followed by the log message.\"\"\" color = self . colors . get ( record . levelno , 0 ) self . _style . _fmt = f \"[ \\033 [ { color } m+ \\033 [0m] %(message)s\" # noqa: W0212 return super () . format ( record )","title":"ConsoleColorFormatter"},{"location":"reference/#yamlfix.entrypoints.ConsoleColorFormatter.format","text":"Format log records as a colored plus sign followed by the log message. Source code in yamlfix/entrypoints/__init__.py 27 28 29 30 31 def format ( self , record : logging . LogRecord ) -> str : \"\"\"Format log records as a colored plus sign followed by the log message.\"\"\" color = self . colors . get ( record . levelno , 0 ) self . _style . _fmt = f \"[ \\033 [ { color } m+ \\033 [0m] %(message)s\" # noqa: W0212 return super () . format ( record )","title":"format()"},{"location":"reference/#yamlfix.entrypoints.load_logger","text":"Configure the Logging logger. Parameters: Name Type Description Default verbose bool Set the logging level to Debug. False Source code in yamlfix/entrypoints/__init__.py 34 35 36 37 38 39 40 41 42 43 def load_logger ( verbose : bool = False ) -> None : \"\"\"Configure the Logging logger. Args: verbose: Set the logging level to Debug. \"\"\" log_level = logging . DEBUG if verbose else logging . INFO logging . basicConfig ( stream = sys . stderr , level = log_level ) for handler in logging . getLogger () . handlers : handler . setFormatter ( ConsoleColorFormatter ())","title":"load_logger()"},{"location":"reference/#yamlfix.model","text":"Define program entities like configuration value entities.","title":"model"},{"location":"reference/#yamlfix.model.YamlNodeStyle","text":"Bases: Enum Represent the desired YAML node style for sequences and mappings. Source code in yamlfix/model.py 8 9 10 11 12 13 class YamlNodeStyle ( Enum ): \"\"\"Represent the desired YAML node style for sequences and mappings.\"\"\" FLOW_STYLE = \"flow_style\" BLOCK_STYLE = \"block_style\" KEEP_STYLE = \"keep_style\"","title":"YamlNodeStyle"},{"location":"reference/#yamlfix.model.YamlfixConfig","text":"Bases: ConfigSchema Configuration entity for yamlfix. Source code in yamlfix/model.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class YamlfixConfig ( ConfigSchema ): \"\"\"Configuration entity for yamlfix.\"\"\" allow_duplicate_keys : bool = False comments_min_spaces_from_content : int = 2 comments_require_starting_space : bool = True config_path : Optional [ str ] = None explicit_start : bool = True indent_mapping : int = 2 indent_offset : int = 2 indent_sequence : int = 4 line_length : int = 80 none_representation : str = \"\" quote_basic_values : bool = False quote_keys_and_basic_values : bool = False quote_representation : str = \"'\" sequence_style : YamlNodeStyle = YamlNodeStyle . FLOW_STYLE","title":"YamlfixConfig"},{"location":"reference/#yamlfix.services","text":"Define all the orchestration functionality required by the program to work. Classes and functions that connect the different domain model objects with the adapters and handlers to achieve the program's purpose.","title":"services"},{"location":"reference/#yamlfix.services.fix_code","text":"Fix yaml source code to correct the format. It corrects these errors Add --- at the beginning of the file. Correct truthy strings: 'True' -> true, 'no' -> 'false' Remove unnecessary apostrophes: title: 'Why we sleep' -> title: Why we sleep . Parameters: Name Type Description Default source_code str Source code to be corrected. required config Optional [ YamlfixConfig ] Small set of user provided configuration options for yamlfix. None Returns: Type Description str Corrected source code. Source code in yamlfix/services.py 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 def fix_code ( source_code : str , config : Optional [ YamlfixConfig ] = None ) -> str : \"\"\"Fix yaml source code to correct the format. It corrects these errors: * Add --- at the beginning of the file. * Correct truthy strings: 'True' -> true, 'no' -> 'false' * Remove unnecessary apostrophes: `title: 'Why we sleep'` -> `title: Why we sleep`. Args: source_code: Source code to be corrected. config: Small set of user provided configuration options for yamlfix. Returns: Corrected source code. \"\"\" # Leave Ansible vaults unmodified if source_code . startswith ( \"$ANSIBLE_VAULT;\" ): return source_code if source_code . startswith ( \"#!\" ): # Skip the shebang line if present, leaving it unmodified eolpos = source_code . find ( \" \\n \" ) + 1 shebang = source_code [: eolpos ] source_code = source_code [ eolpos :] else : shebang = \"\" yaml = Yaml ( config = config ) fixer = SourceCodeFixer ( yaml = yaml , config = config ) source_code = fixer . fix ( source_code = source_code ) return shebang + source_code","title":"fix_code()"},{"location":"reference/#yamlfix.services.fix_files","text":"Fix the yaml source code of a list of files. If the input is taken from stdin, it will return the fixed value. Parameters: Name Type Description Default files Files List of files to fix. required dry_run Optional [ bool ] Whether to write changes or not. None config Optional [ YamlfixConfig ] Small set of user provided configuration options for yamlfix. None Returns: Type Description Union [ Optional [ str ], Tuple [ Optional [ str ], bool ]] A tuple with the following items: Union [ Optional [ str ], Tuple [ Optional [ str ], bool ]] Fixed code or None. Union [ Optional [ str ], Tuple [ Optional [ str ], bool ]] A bool to indicate whether at least one file has been changed. Source code in yamlfix/services.py 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 def fix_files ( # pylint: disable=too-many-branches files : Files , dry_run : Optional [ bool ] = None , config : Optional [ YamlfixConfig ] = None , ) -> Union [ Optional [ str ], Tuple [ Optional [ str ], bool ]]: # noqa: TAE002 \"\"\"Fix the yaml source code of a list of files. If the input is taken from stdin, it will return the fixed value. Args: files: List of files to fix. dry_run: Whether to write changes or not. config: Small set of user provided configuration options for yamlfix. Returns: A tuple with the following items: * Fixed code or None. * A bool to indicate whether at least one file has been changed. \"\"\" changed = False if dry_run is None : warnings . warn ( \"\"\" From 2023-01-12 fix_files will change the return type from `Optional[str]` to Tuple[Optional[str], bool], where the first element of the Tuple is the fixed source and the second a bool that returns whether the source has changed. For more information check https://github.com/lyz-code/yamlfix/pull/182 \"\"\" , UserWarning , ) for file_ in files : if isinstance ( file_ , str ): with open ( file_ , \"r\" , encoding = \"utf-8\" ) as file_descriptor : source = file_descriptor . read () file_name = file_ else : source = file_ . read () file_name = file_ . name log . debug ( \"Fixing file %s ...\" , file_name ) fixed_source = fix_code ( source , config ) if fixed_source != source : changed = True if file_name == \"<stdin>\" : if dry_run is None : return fixed_source return ( fixed_source , changed ) if fixed_source != source : if dry_run : log . debug ( \"Need to fix file %s .\" , file_name ) continue if isinstance ( file_ , str ): with open ( file_ , \"w\" , encoding = \"utf-8\" ) as file_descriptor : file_descriptor . write ( fixed_source ) else : file_ . seek ( 0 ) file_ . write ( fixed_source ) file_ . truncate () log . debug ( \"Fixed file %s .\" , file_name ) else : log . debug ( \"Left file %s unmodified.\" , file_name ) if dry_run is None : return None return ( None , changed )","title":"fix_files()"},{"location":"reference/#yamlfix.version","text":"Utilities to retrieve the information of the program version.","title":"version"},{"location":"reference/#yamlfix.version.version_info","text":"Display the version of the program, python and the platform. Source code in yamlfix/version.py 11 12 13 14 15 16 17 18 19 20 def version_info () -> str : \"\"\"Display the version of the program, python and the platform.\"\"\" return dedent ( f \"\"\" \\ ------------------------------------------------------------------ yamlfix: { __version__ } Python: { sys . version . split ( \" \" , maxsplit = 1 )[ 0 ] } Platform: { platform . platform () } ------------------------------------------------------------------\"\"\" )","title":"version_info()"},{"location":"adr/adr/","text":"ADR are short text documents that captures an important architectural decision made along with its context and consequences. graph TD 001[001: High level analysis] 002[002: Initial Program design] 001 -- Extended --> 002 click 001 \"https://lyz-code.github.io/yamlfix/adr/001-high_level_problem_analysis\" _blank click 002 \"https://lyz-code.github.io/yamlfix/adr/002-initial_program_design\" _blank 001:::draft 002:::draft classDef draft fill:#CDBFEA; classDef proposed fill:#B1CCE8; classDef accepted fill:#B1E8BA; classDef rejected fill:#E8B1B1; classDef deprecated fill:#E8B1B1; classDef superseeded fill:#E8E5B1;","title":"Adr"}]}